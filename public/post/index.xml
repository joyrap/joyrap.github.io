<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on </title>
    <link>//localhost:1313/post/</link>
    <description>Recent content in Posts on </description>
    <generator>Hugo 0.125.0</generator>
    <language>en</language>
    <lastBuildDate>Mon, 08 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mixin in Java</title>
      <link>//localhost:1313/post/2024-01-08-java-mix-in/</link>
      <pubDate>Mon, 08 Jan 2024 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2024-01-08-java-mix-in/</guid>
      <description>什么是Mixin 维基百科的解释是：&#xA;In object-oriented programming languages, a mixin is a class that contains methods for use by other classes without having to be the parent class of those other classes. How those other classes gain access to the mixin&amp;rsquo;s methods depends on the language. Mixins are sometimes described as being &amp;ldquo;included&amp;rdquo; rather than &amp;ldquo;inherited&amp;rdquo;.&#xA;简而言之就是：通过组合而不是继承的方式获得其他类所提供的功能。&#xA;Java中是如何做到的 面向对象编程语言可以通过继承来达到功能复用目的，但继承也会有不少陷阱，或者说有时候他们并不满足设计上的需求。&#xA;例如我们想让类具备另外多个已经存在于其他类中的功能，那么通过继承就无法实现，因为Java不允许多重继承。而且子类会全部继承父类的开放功能，也不是我们期望的，在Effective Java中也推荐优先选择复合而不是继承。&#xA;从关系类型上来说，我们也不希望为了获得某个功能，让类之间成为IS-A的关系。&#xA;这时候我们自然想到的就是接口，接口作为开放的协议约定，所有类都可以实现接口，同时类可以实现多个接口。为了让类可以实现接口同时又能获得默认实现，Java在接口中设计了default默认实现方法，这样子类可以在不需要自己实现的情况下获得接口中默认提供的功能（这里的default方法还解决了新增接口方法导致实现类变更的问题），变相地实现了多继承。&#xA;例如下面这种情况：&#xA;class A{ ... } interface B{ ... default void show(){}; .</description>
    </item>
    <item>
      <title>诗二(你的江河)</title>
      <link>//localhost:1313/post/2023-10-18-yichang/</link>
      <pubDate>Tue, 17 Oct 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2023-10-18-yichang/</guid>
      <description>我愿化作江河，在你的城市&#xA;默默流过这一生&#xA;用浪头敲打彼岸，拍醒礁石&#xA;待你来我身边，赶在最后一日斑驳黄昏&#xA;数一遍碎云&#xA;洗一次长发&#xA;落一回脚&#xA;我是你的江河，在你的城市&#xA;把岁月流得好长，好长</description>
    </item>
    <item>
      <title>How to Do great work</title>
      <link>//localhost:1313/post/2023-08-29-how-to-do-great-work/</link>
      <pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2023-08-29-how-to-do-great-work/</guid>
      <description>最近Paul Graham写了一篇博客，阐述了他对“如何做事（工作）”的一些观点，致于你做的事情是否是Great的， 我想对普通人来说可能并不重要。&#xA;这篇文章太长，还没读完，我提取了其中一些感兴趣的观点，原文链接放在了最后。&#xA;做事之前先想想三个问题，第一，你是否具备这方面的天赋，第二，你是否具有浓厚的兴趣，第三，是否有大的平台来成就你。大部人第三个问题不用过于担心。 大部分人年轻时都很茫然，不知道要做什么，无法选择某种终身追求的职业。 一开始就想从事自己感兴趣的工作，这几乎不可能，因为很多时候你会因为只喜欢某个工作，而忽略了其他可能性。很多时候你需要去尝试不同的工作，通过工作来培养兴趣，这完全没有关系，很多工作领域其实是相通的。 尽可能行万里路，读万卷书，交不一样的朋友，尝试不同的工作。 只要是兴趣和好奇心驱使，不要怕换工作，你不会辜负工作，因为工作不是人。 做事要养成主人翁精神，不是别人告诉你要做什么，只有这样才能取得出色的工作 人的激情会随着年龄和时间的推移发生变化，但一直保持激情和好奇心很关键，如果你想成就伟大的事业，这是必不可少的品质。 如果对你自己关注的事情，保持超出常人理解的关注程度，那也许就是你所寻觅的。 一旦你找到了你喜欢的事情，就去学习它相关的知识，深入了解它，有必要成为该领域的专家。 大部分科学领域的发展，都是有人提出了不一样的疑问，这些问题可能会改变这一领域的发展和认知，如果你对某个领域有一些奇怪的想法，那就想办法弄清楚他，这可能是你真正的机会。 有了兴趣和好奇心，然后就是学会工作的技巧，工作是一个累积效应，滴水石穿的过程，你要耐得住。 年轻的优势就是乐观，乐观的根源就是无知，无知往往给你莽撞前行的动力，这并不是坏事。 给你的工作定义一个自己认为的”完成“，事事有回应 件件有着落 凡事有交代。 当你觉得自己很忙的时候，停下来问自己：这是我想做的事情吗？ 培养对自己工作的品味，知道在你所在的领域，什么样才是优秀，你不一定会成为优秀，但是要努力靠近优秀，成为最好的。 很多人和事情都会随风而逝，伟大的事业就是去尝试作出100年后人们依然会关心的东西，不是因为未来的人观点比你当前的观点更重要，而是因为100年后依然看起来不错的东西，有可能才是真正的好东西。 &amp;hellip;&amp;hellip;&#xA;原文地址</description>
    </item>
    <item>
      <title>如何画软件系统架构图</title>
      <link>//localhost:1313/post/2023-08-16-how-to-draw-architectural-diagrams/</link>
      <pubDate>Wed, 16 Aug 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2023-08-16-how-to-draw-architectural-diagrams/</guid>
      <description>最近看了一篇如何画软件架构图的博客，结合个人的一些经验，整理总结一下。&#xA;一图胜千言 当你要描述一个复杂系统中各个组件之间的交互关系，组件之间还存在复杂的数据流转，仅仅只用文字很难对主题快速地树立形象的表达，这时候就需要用到架构图，架构图可以应用于很多领域，例如建筑，工程，IT，产品，销售等等。&#xA;下面这张图就是一个非常好的案例，来至The Code Review Pyramid:&#xA;它有以下几个特点：&#xA;明确的主题 信息分层 使用金字塔表达不同信息的权重 文字提示 使用箭头 不同的配色 设计图与架构图 许多人混淆了两者之间的区别，架构图描述的是你正在构建的系统状态，组件之间的交互关系以及相互约束，设计图是你将要如何构建系统（未完成）。&#xA;例如：假设你正在建造一个足球场，架构图告诉你架构师想要什么，其中很多细节涉及到多个领域，但是架构图的主要目的是表达如何满足各方的需求，设计图则是如何逐步实现这些需求。&#xA;架构图的两个作用 1.有助于理解系统 一图胜千言，一张架构图可以传递复杂的信息。&#xA;可以在图上看到系统全景，组件之间的上下游关系，以及他们如何互相影响。 架构图可以将组件关系和流程分层表达，从中可以自由地关注整体或局部。 2.改善沟通和协作 软件工程师面临的主要问题之一是一致性，特别是多方参与的系统，团队之间沟通的主要障碍就是理解上的不一致，所以架构图也有助于信息标准化。&#xA;软件系统架构图的类型 软件架构图可以根据你表达信息的偏向，大致分为以下几类：&#xA;应用架构图 应用架构图用于表达软件系统的结构布局以及它如何与其他系统交互，这一类架构图旨在高度抽象组件如何构成系统。通常将关系图分组为层，这些层详细说明系统在不同级别的工作方式。&#xA;数据架构图 数据是系统的核心，一个庞大的系统往往伴随着各种业务数据，数据架构图提供数据如何在系统中流转的概况，当你想查询数据，或者扩展系统时非常有帮助。&#xA;集成架构图 集成架构图提供组件内部如何协作，以及如何与外部系统配合，集成架构图对设计和部署非常有帮助。&#xA;如何画架构图 1.为不同的图形做好文档 一张架构图中，你可能选择多个不同的形状表达不同的含义，为了避免混乱，可以对不同图形进行标注说明，保持全局一致性。&#xA;例如下面这张图： 你可以标注不同颜色的线框的含义。&#xA;2.不同图形背后的含义 图形大小，直觉上可以表达量词的比较关系，例如：快与慢，多与少，等等。&#xA;例如：&#xA;3.图形的不同线框 图形的边缘，你可以选择实线，虚线，直角线框，还是圆角线框。&#xA;4.保持箭头指向一致性 箭头的使用很多人最容易犯错，箭头可以表达数据流，或者依赖，如果你想用箭头表达其他关系，但最好不要混合交叉使用。&#xA;5.谨慎使用颜色 如果要使用颜色，越少越好，同时颜色也需要保持一致性。你可以给线框，背景，文字设置不同颜色。&#xA;切记：颜色具有一种很强的暗示，使用过多不同的颜色，会增加理解成本。&#xA;6.有必要使用多个图 有时候你需要向不同知识背景的人展示架构图，项目的不同干系人关心的内容不太一样，只有一张架构图不能满足不同的受众。&#xA;7.合并不完整的图 如果两个关系图都表示一个流程或系统，但它们不完整，请考虑合并它们。&#xA;8.包含说明，关键词，和词汇表 有必要给图提供说明，关键词和词汇表，但尽量准确和简洁。&#xA;9.使用绘图软件 头脑风暴时你可以只用笔和纸，如果需要将架构图作为团队知识库长期迭代，而不是用完一次就扔掉，那么你就需要借助画图软件。（我之前整理过一篇图表即代码的文章），绘图软件也有利于让架构图信息标准化。&#xA;注意事项 组件之间的关系要完整，不要有孤立的元素。 如果要用简写，缩写，或者特殊的专业术语，最好维护在词汇表。 相同的术语要统一，而且准确。 标注不清楚的术语，最好说明原因。（难免会有疑问的地方） 你要在架构图中完整展示你想表达的内容。 避免过多或太少的信息展示，这是一个平衡取舍技巧。 你也可以参考C4 model提出的规范，从4个维度来画软件架构图，与上面提到的内容没有冲突。&#xA;总结 许多软件项目缺乏适当的文档，因为人们认为维护文档是一件非常耗时的事情。但是没有架构图就像试图在没有规划路线的情况下开车去某个地方一样， 总有一天你会迷路，不得不尝试倒退到起点，周而复始。&#xA;最后，强烈推荐这个通过画图来讲计算机相关技术的Newsletter，他们的技术文章配图都非常精美。&#xA;参考 Architectural diagrams: what to know, and how to draw one 图表即代码 C4 model </description>
    </item>
    <item>
      <title>2023阅读清单</title>
      <link>//localhost:1313/post/2023-reading-list/</link>
      <pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2023-reading-list/</guid>
      <description>大部分书都只是选读了其中部分章节。&#xA;生命是什么 - 薛定谔&#xA;科学家从物理角度解释生命是什么，非常有趣且有深度的视角，很多章节看不懂，后面再找其他翻译版本来看看。&#xA;费曼讲物理：入门&#xA;深入浅出，非常有趣。&#xA;How to Live 27 Conflicting Answers And One Weird Conclusion&#xA;英文版的心灵鸡汤，大部分都是英文短句，单词量也不大，阅读起来很轻松，非常适合学习英语。&#xA;活着回来的男人：一个普通日本兵的二战及战后生命史&#xA;从一个被战争推着走的底层小人物视角讲述二战，即使是导读里面讲的那段吴雄根的经历，也让人唏嘘不已。&#xA;江城 - 彼得·海斯勒（何伟）&#xA;这本书大部分内容是在地铁上读完的，听说这本书的美国读者众多，当然中国读者也不少，作为一个四川人在读这本书的时候有特别的情感，尤其是描写小人物的生活点滴， 彼得·海斯勒有极强的洞察力，很多主题都比较敏感，三峡大坝，金钱，权力，政治，排外，偏见，虽然视角在重庆涪陵，但很多场景描述至少在四川省范围内来说是极其真实的。何伟也对不同文化背景下认知差异一开始感到困惑，到后面能够融入其中并深切理解，这大至得益于他刻苦学习了中文，特别是地方方言，这非常难得，我对这本书有些自己的看法：&#xA;这本书的英文版River Town: Two Years on the Yangtze (P.S.)第一版出版时间是2006年，已经过去了15年，也就是说这本书是中国改革开放后期出版的，中国人在很多方面有了改变，但是如果外国读者忽略了这个事实，可能多少会影响对中国的认识。 从纪实文学角度来说，这应该是继马可·波罗游记之后，另一部外国人对中国人的描写吧，尽管这两本书在结构和形式上有巨大的区别。 如果给何伟更多的时间，他会比我们中国人更了解我们自己，毕竟旁观者清。 不清楚中文简体版，译者是否有添油加醋，因为中文版本有些句子明显很有深度，有打磨过的痕迹。 作为一个中国人，我们时刻要问自己：我们的国家变了吗。 “读完这本书后，对一个中国人来说，我成了外国人。”&amp;mdash;&amp;mdash;来至豆瓣网友评论 重来3：跳出疯狂的忙碌&#xA;一个公司老板站在员工的角度讨论如何保持小而美，这和中国主流企业文化大相径庭，背道而驰。遍地都是追逐利益增长的企业，可个体的生命终究短暂。&#xA;经济学思维方式（第13版）&#xA;阅读中&amp;hellip;&amp;hellip;</description>
    </item>
    <item>
      <title>我的姑姑</title>
      <link>//localhost:1313/post/2023-07-30-my-aunt-passed-away/</link>
      <pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2023-07-30-my-aunt-passed-away/</guid>
      <description>姑姑已经去世了好几年，但想起她总有些特别的记忆，日子渐长，那些记忆却还停留在原处，总觉得写下来比较好。&#xA;山的那一边 姑姑和娘家就隔着一座山，山不算高走小路最多不过四十分钟的路程，那时候真是通讯基本靠吼的年代，有什么消息要互相转告，就站在山头上喊对方的名字，喊声响彻山谷，有人听到就帮忙传达，我在山头喊过无数次姑姑。&#xA;不知道为什么姑姑出嫁的地方离娘家这么近，这事儿也许只有去世的奶奶最清楚。&#xA;隔山隔水，却总能一眼相望。&#xA;一碗鸡蛋 农忙季节我总去姑姑家帮忙，便成了常客，农村什么都缺，唯独鸡鸭鹅遍地跑，家禽是农村赶集贩卖的最好农产品，也是比较重要的收入。&#xA;就算再忙姑姑都要弄上一大碗白糖水和四个水煮鸡蛋，以前人小不懂人情世故，吃不完还要被骂，成年后，姑姑还是照旧会煮鸡蛋，但吃不完也就不再强求，好几次我都故意剩下，因为姑姑会把剩下的鸡蛋吃掉。&#xA;我有时候会觉得，一个农村人双手忙碌着从柴火堆里灰头土面地煮好一捧食物，总带着烈火一般的热情，让人怎能不心生暖意，不是盛情难却，是骨子里的同命相连。虽然地里长不出金银财宝，但他们恨不得每年都把自己栽在土里，这样可以自给自足卑微地活着，久而久之，他们确信自己就是从地里长出来的，离不开土地。&#xA;达情通理 有一次在姑姑家帮忙收地里的红薯，表哥在城里上大专，姑姑闲聊时说无论多苦多累，都要让表哥完成学业，熬到他出人头地，那时候父辈们心里有一个重要的思想，就是大专毕业可以分配工作，我不清楚姑姑是认为分配工作重要，还是读书重要，但她说到再苦再累的时候，毫无畏惧的神情让我难忘，一种对未来的无限憧憬。&#xA;很多年后我认为，不是知识改变命运，其实是命运改变了对读书的看法，只是在那片土地上的人并没有这种意识。&#xA;读取功名意味着把自己从地里拔出来，与他们那一辈人注定要形成割裂，但即便如此总算是一种正道。&#xA;无论如何，姑姑是一个期望在能力范围内尽到最大责任的长辈。&#xA;后来我高中缀学在家，趁机跑到姑姑家住了两晚，姑姑对我不能继续上学感到惋惜，同时唠叨我父亲如何目光短浅和不可理喻，要亲自说他几句，我父亲与姑姑su lai&#xA;记得一天早晨，姑姑说我表姐夫在做小生意，如果不继续上学，要不跟他去学个手艺吧，我没说话，也没同意，临走时姑姑在裤兜里抠了半天，掏出五元钱给了我，让我回家和父亲好好聊聊。&#xA;病况 姑姑一家是典型的川东农户，世代以务农为生，包产到户后，虽然还是穷，难得吃上一顿肉，但也不至于饿着肚子。劳作辛苦，积劳成疾，那时候的大部分农村人以为年轻时身强体壮可以扛过岁月，一些病患忍忍就过去了。&#xA;所以意外之外也是情理之中，在一次体检中姑姑查出肿瘤晚期，七十多岁算不上年迈，但多少还是有些难以接受。&#xA;此时表哥毕业多年，在城里的小生意做得有些成就，带着姑姑做了几次化疗，但医生的意思还是一切交给时间。&#xA;最后一次见到姑姑 几个月后，表哥说姑姑的病情正在加重，目前在南充市医院抢救，我就跟着去了医院。&#xA;病床上的姑姑意识还清醒着，我摸着她的脸，问她痛不痛，她说有时候头晕起来有点恶心（因为肿瘤扩散到了头部）。&#xA;姑姑还是那样健谈，家常理短说个不停，但说来说去都还是那片土地上的事情，只是声音没有了以往的高亢。&#xA;她问我过得好不好，关于我的很多事情都是从我父亲口中听到的，说话间交待了一些事情，我都没记下来。&#xA;表姐，表哥，表妹都在，悄悄讨论如何办理后事。&#xA;医院的意思，目前这个情况在医院待着消耗钱，还不如回家做好准备。&#xA;后来，表哥带着姑姑出院回了老家。&#xA;不同的价值观 表哥一家都回到了老家轮流照顾姑姑，儿女们发现之前买的名贵补品（虫草，人参）在家里都开始发霉，姑姑一样都没吃。&#xA;大家骂骂咧咧，来回指责，唯独姑姑一声不吭，我猜这时候躺在床上的姑姑，就算没有得病，应该也不知道如何回答他们，孩子们没长大时，平日里总会唠叨自己那套价值观，现在孩子大了，说什么也没了用，说得不开心怕孩子们就各自鸟兽散。&#xA;如果离开土地太久，总会忘了吃土长大的日子，这就是割裂中的固执。&#xA;下葬 两周后，姑姑去世了。&#xA;我也回到了老家，下葬前一晚和父亲一起去守夜，当晚法师们有说有笑，所有流程按部就班。&#xA;冬夜寒气逼人，这些年农村住户越来越少，盏白炽灯下，大家围着火炉，阵阵敲锣声在山沟里来回荡漾。&#xA;期间，表姐们说姑姑终于得到了解脱，不再有痛苦，还不忘指责其有生之年没学会如何放下，去享受生活。&#xA;农村人不会文绉绉地表达爱，他们认为骂骂咧咧的指责就是对一个人的好，谁曾想过姑姑的命运其实早烙在了掌纹上，注定不能被改变，儿女们的假设只是一厢情愿。&#xA;她有生之年只会不厌其烦地表达对儿女们的关心，尽管这种关心在成家立业的儿女们看来显得无足轻重，甚至多余。&#xA;平日里孩子们只管定期从家里拿走鸡鸭和蛋，但永远无法回报父母的爱。&#xA;儿女们困在自己的生活里，整日与家事斡旋，哪有能力给与父母想要的陪伴。&#xA;遗憾总是注定的，这很像诗人韩东说的那样：&#xA;我们以为我们可以爱一个活着的母亲，&#xA;其实是她活着时爱过我们。&#xA;从此，平行世界的两种爱，阴阳相隔。&#xA;活着的意义 我一直认为对活着的人万般好，就是对其死后最好的告别。&#xA;作家余华说：“父母是你和死亡之间那个垫背的&amp;hellip;&amp;hellip;”。&#xA;我没见过真正从土里长出来的人，倒是见了很多人，像种子一样被埋到土里，最后淹没在杂草间，日渐模糊。&#xA;活着的人节日里对着土堆烧香磕头，哭长哭短，万千感慨，只是敬了山水。</description>
    </item>
    <item>
      <title>诗一</title>
      <link>//localhost:1313/post/2023-07-03-a-poem/</link>
      <pubDate>Mon, 03 Jul 2023 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2023-07-03-a-poem/</guid>
      <description>傍晚&#xA;我躺在丰收后的油菜壳里&#xA;仰望着故乡的天空&#xA;有几只飞鸟&#xA;吃掉了刚刚升起的星星&#xA;人们无数次带走大地的礼物&#xA;忘了汗水&#xA;那一夜&#xA;睡得很深，一直深到土里</description>
    </item>
    <item>
      <title>2022结束了吗</title>
      <link>//localhost:1313/post/2022-12-28-2022-is-the-ending/</link>
      <pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2022-12-28-2022-is-the-ending/</guid>
      <description>我理解的结束，一种是生命的终结，另一种是绝望。&#xA;疫情 三年多来，疫情已经变成了一个复杂的社会话题，在这场洪流中个人体到了，国际阴谋论，封城，囤积物质，地域歧视，隔离，祖国统一，火速支援，生死离别&amp;hellip;&amp;hellip;等等，尽显人生百态。&#xA;最常见的还是普通人在劣质的网络信息流中，无畏地发泄那些毫无力量的个人情绪。&#xA;我们要面对现实中的混乱，还要对抗外部信息对主观意识的冲击，让我不禁思考一些问题：我们是否只是在个体内部用狭隘的聪明自圆其说，我们担心的到底是什么，我们何以脱身，我们该如何获得智慧，而不是一时的聪明？&#xA;福兮祸所伏,祸兮福所倚&#xA;感染新冠病毒对年迈的老人来说，有些不幸，目前对我来说却是福音，因为在感染新冠病毒之前，我犯有慢性荨麻疹（折磨了我长达6年之久），长期要服用抗过敏药物，这种病最大的困扰就是会影响睡眠。在感染新冠病毒康复后，荨麻疹也彻底好了，这算不算一个医学奇迹。&#xA;聪明与智慧 我们该如何获得智慧？&#xA;一 经历过上面提到的疫情大事件后，大部分人都会累积一些生活经验，比如如何应对紧急情况，如何囤积食物，如何戴口罩防护，如何酒精消毒。&#xA;个人也在疫情期间，鉴于对过敏性荨麻疹的好奇，读了3本关于疾病的科普书：&#xA;《我们为什么还没有死掉》 《我们为什么会生病》 《消失的微生物》 这些书解答了我的一些疑惑，对空白知识领域进行了一次扫盲，更重要的是纠正了一些习惯性认知误区。&#xA;例如：你在生活中经常会听到一些说法：某某药物（或者食物）可以提高免疫力，增强免疫系统。 这句话极具诱惑性的原因是关键词增强。&#xA;人类的免疫力是一个非常复杂的系统，即便是现代科学对免疫系统也是知之甚少，甚至还不如对癌症的了解程度，但有些常识你要知道，免疫系统不能被增强，因为免疫系统在人体内是一个动态的状态，他与外界时刻保持信息交换，它只能被所处的环境调节，目前已知最有效的调节方法就是注射疫苗。&#xA;个人猜测，感染新冠让我的免疫系统发生了变化，这是好还是坏并不确定，至少心理上少了很多负担，总之对于自身疾病，焦虑和恐惧都是毫无意义的。&#xA;学习知识在某种程度上，只是让你变得聪明了一点点，但聪明在时间长河中其实是短暂的，它不足以成为智慧。&#xA;二 前不久听过一档播客节目：一个北京人在武当山当义工的笔记。其中有一期他讲到武当山上的道长对“贪昧”的解释，大意是说：那些渴求知识，专研技术的人，和爱慕钱财，争名夺利的人，其实是一样的，在他们认知里，都是贪，所以没有高低好坏之分，贪昧是一种中性的行为现象。&#xA;多既是少，少既是多。&#xA;我理解这就是道家的智慧。&#xA;三 心理学教授乔丹·彼得森，写过两本书叫《人生十二法则》，可能作者做过很长的临床心理咨询工作，说好了只说十二条人生法则，但第一本《人生十二法则》出版两年后，又写了一本《人生十二法则2》，在第二本法则中提到的法则三： 做好生活中不断重复的事情，给了我很大的启发。&#xA;现代人都在抱怨年复一年的早九晚五，三点一线，可是你有没有想过，一日三餐才是生活的常态，你要面对的就是日复一日重复的小事情。&#xA;你要和家人讨论，周末谁洗衣服，谁打扫卫生，谁做饭&amp;hellip;&amp;hellip;&#xA;你的幸福感部分来自于生活中对重复小事情的掌控感，而不是变成破坏亲密关系的负面情绪，不要因为不得不做的小事情引起家庭冲突。&#xA;乔丹·彼得森的生活智慧，对我有极大的教育意义。&#xA;读加缪 本来打算在疫情期间读完加缪的《鼠疫》，却意外地读了《局外人》，最终的结果也不算遗憾，有所收获总算好事。&#xA;《局外人》的故事固然精彩，但让我印象深刻的还是里莫尔索说的那句:&#xA;人只要智力健全，都或多或少地希望自己所爱的人死去&#xA;看似荒诞，却又体现了主人公对人情世故的无奈，有人把这句话解释为：&amp;ldquo;因为你爱的人，对你有期望，对你有牵挂。因为你爱的人，你必须要承担社会的责任。所以，莫尔索认为，人类有时想逃避社会时，就希望那些自己爱的人不在这个世界上该有多好。&amp;rdquo;&#xA;平行世界，主观上自带偏见，你未曾经历过别人的苦难，为何又要对他人过早地下结论。&#xA;这就是诺贝尔文学奖获得者，存在主义作家加缪的成名作，给我们带来不一样的视角。&#xA;也正式这种荒谬现象的认知，让我反观疫情中这些种种怪诞的社会现象，认识到不朽文学的价值。&#xA;疫情过去了，那本《鼠疫》却还在书架上来不及拆封。&#xA;玩物且不丧志 疫情期间，我又拿起了年少时的笛子，感叹笛箫的制作工艺是真的变化太大，这一次为了更好地提升笛箫技能，我绘制了一张平时练习的脑图（点击查看)&#xA;疫情结束了吗 最后，这场疫情结束了吗？&#xA;聪明的人会说，它过去了，&#xA;智慧的人会说，这一切并没有结束。</description>
    </item>
    <item>
      <title>无题</title>
      <link>//localhost:1313/post/2022-07-31-no-title/</link>
      <pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2022-07-31-no-title/</guid>
      <description>盛夏，酷热。&#xA;&amp;ldquo;发一份辣椒酱制作菜谱给你，可好&amp;rdquo;&#xA;&amp;ldquo;你不在，我不想把时间花在做饭上&amp;hellip;&amp;hellip;&amp;rdquo;&#xA;时光啊你别催，&#xA;待我与爱辛酸，缠绵，淡薄后，这就来。</description>
    </item>
    <item>
      <title>API设计之版本控制</title>
      <link>//localhost:1313/post/2022-04-09-api-design-versioning/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2022-04-09-api-design-versioning/</guid>
      <description>为了追求系统的健壮性，稳定性，越来越多的系统采用分布式软件架构，分布式意味着跨应用访问成为系统交互的一种特点，特别是微服务架构在商业系统中的大量运用。&#xA;API作为应用之间交互协议，当单体应用演变为远程调用后，API持续变更成为一个跨应用或跨团队之间协作的常态，如何维护API，在研发过程中变得尤为重要，非常有必要将API版本控制作为设计的一部分来重视。&#xA;目的 API版本控制的目的是为了降低API在迭代过程中对用户的影响，并提供一套对第三方开发者有利的演进规则，以及升级策略，尽可能避免用户功能被破坏。&#xA;发布管理 变更管理 从服务提供方的视角来看，版本发布与服务实现变更是密切相关的，同时也会对第三方开发者带来影响，所以服务方需要严格管理API版本发布内容，每次发布对API做出不限于以下情况的说明：&#xA;是否在协议不变更的情况，进行了服务优化？ 是否在老协议上新增了入参，新入参对内部业务逻辑有什么影响？ 新增协议与现有协议之间有什么关系，是否是独立的？ 新增协议接口与老接口哪些内容不兼容？告知第三方开发者如何升级。 有些较为庞大的组织，按系统维度进行了API划分，变更说明也应该以系统维度来说明。&#xA;变更的影响说明可以大致分为以下三类：&#xA;1、 API架构变化（影响范围较大，不能兼容） 2、 局部新特性变更（影响较小，提供兼容） 3、 问题修复（完全兼容） 变更说明应该以公开文档的形式公布给第三方开发者。&#xA;生命周期管理 对于整个API来说，必须以两种视角来看到API版本，一种是第三方开发者视角，一种是API服务视角。&#xA;尽管对API进行生命周期管理，好处在于一方面可以控制内部开发节奏，另一方面给第三方开发者提供调试和升级时间。但是在API版本号与API服务内部同时演进的情况下，第三方开发者并不关心API服务内部的演进路线， API服务方也应该尽量减少第三方开发者的理解负担，所以API版本号的变更不易过于频繁。&#xA;不同的业务和产品，对API版本发布的周期管理会有所不同，主要有以下两种主流的版本化管理策略：&#xA;1、基于时间发布 对不同的变更影响，定义不同的发布周期，例如，将API架构变化这种影响范围较大的场景，周期时间应该更长，其次是局部新特性变更，问题修复发布周期最短。&#xA;API架构变化：每三个月发布一次，局部新特性变更：每三周发布一次，问题修复：每周一次。&#xA;不同的业务，可以调整这个周期，但时间周期长短上应该遵循：问题修复 &amp;lt; 局部新特性变更 &amp;lt; API架构变化&#xA;基于时间周期发布，对于第三方开发者来说的好处是可预知性，有明确的API支持时间范围，何时过期，何时被删除。&#xA;1、基于语义化版本号发布 基于语义化版本号的三个维度来管理，例如，版本号:主版本号.次版本号.小版本号&#xA;1、主版本号（对应API架构变化） 2、次版本号（对应局部新特性变更） 3、小版本号（对应问题修复） 版本号发布方式，常用于不需要周期发布的产品，或API在较长的时间范围内稳定的产品。&#xA;同时需要注意：语义化版本号策略更多地是来至API服务方的视角，主要目标是跟踪API不同的兼容性问题。&#xA;基于WEB的API版本发布方案 对于REST API可选的三种方案：&#xA;方案1：将版本号放到路径中，例如：https://api.akulaku.com/v1.0/products/users 或使用不同的域名 https://apiv1.akulaku.com/products/users 方案2：将版本号放在HTTP header头中，例如，在header中放入：v=1.0 方案3：将版本号放到参数中，例如：https://api.akulaku.com/products/users?api-version=1.0 方案1和2都需要借助DNS或API网关对请求路由，不同版本的API路由到不同的API服务上。&#xA;方案3则需要API服务内部管理版本号映射&#xA;API版本号 API内部服务版本号 v1.0 v1.0.0，v1.0.1 v2.0 v2.0.0 &amp;hellip;&amp;hellip; &amp;hellip;&amp;hellip; 案例 Shopify Shopify作为全球最大的一站式商家平台，强大的API为其提供了核心竞争力。&#xA;Shopify的API管理区分了两类API，一类是非版本化的API，一类是版本化的API， 其中版本化的API是基于时间发布。&#xA;例如官方给的REST API demo：/admin/api/2022-07/products.json&#xA;同时官方也提供了API状态周期表：&#xA;Stable version Release date Date stable version is supported until 2021-01 January 1, 2021 January 1, 2022 2021-04 April 1, 2021 April 1, 2022 2021-07 July 1, 2021 July 1, 2022 2021-10 October 1, 2021 October 1, 2022 给第三方调用者提供了明确的API支持时间。</description>
    </item>
    <item>
      <title>A Philosophy Of Software Design-读书笔记</title>
      <link>//localhost:1313/post/2022-01-08-a-philosophy-of-software-design/</link>
      <pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2022-01-08-a-philosophy-of-software-design/</guid>
      <description>《软件设计的哲学》这本书最早出版于2018年，2021年出了2nd Edition，目前国内还没有中文版，这本书是作者 在斯坦福大学开设的CS190课程大纲。 我专门搜索了一下国内软件专业的大学，基本上都没有关于软件设计的课程。&#xA;市面很多关于软件设计的书籍，大部分都是基于某些特定编程语言或者技术，还没有一本全面讲解软件设计本身的书。&#xA;软件设计本来是一种创造性活动，主观性极强，本书作者的基调还是鼓励利用一切手段来考虑系统的设计性，有些做法比较激进。&#xA;这里尝试将其中精彩部分做点翻译，结合自己的理解便于学习。&#xA;2. The Nature of Complexity &amp;lt;复杂性的本质&amp;gt; 这本书是关于如何设计软件系统并最小化复杂性，首先你得了解你的敌人，明确什么是“复杂性”？你如何描述一个系统复杂性？是什么让系统变得复杂？ 本章将在一个更高维度阐述这些问题。&#xA;识别复杂性是重要的设计技能，它让你在处理问题之前明确问题所在，让你在众多选择中作出好的选择。&#xA;2.1 Complexity defined &amp;lt;复杂性的定义&amp;gt; 任何使软件系统难于理解和修改的东西，即是复杂性。复杂性以不同方式存在，比如它可能是一段难于理解的代码，它可能是需要付出巨大努力才能实现一个很小的优化， 它可能是错综复杂的关联中难于修复的BUG。&#xA;复杂性是一个开发人员在某个时间点上试图完成某个特定目标的过程，它不一定是整个系统功能。人们直觉上认为具有大量功能的大型软件系统是”复杂“的，但是这样的系统如果容易实现 ，那么对于本书的定义来说，他就不算复杂。当然几乎所有的大型软件系统实际上都是复杂到难于实现，他们或多或少都会出现我定义的复杂性，也不是说没有复杂功能的简单系统就不可能出现复杂。&#xA;复杂性是由大多数常见的活动决定的，如果一个系统只有很少一部分是复杂的，但它们不影响整个系统复杂性。&#xA;我们可以用一个简单的数学公式来描述系统复杂性：&#xA;$$ C=\sum_{p}c_{p}t_{p} $$&#xA;（p为系统的组件数量，c为组件的复杂性，t为完成组件投入的时间）&#xA;系统的整体复杂性由组成部分乘以开发人员在其投入的工作时间，将复杂性隔离在不容易被发现的地方不亚于完全消除复杂性。&#xA;复杂性相对于作者而言对读者更显而易见，当事者总会觉得他们写的代码似乎很简单，但其他人却觉得复杂。如果你遇到这种情况，试着询问其他 开发人员，为什么你写的代码在他们看来这样复杂，从交流中找到你与他们之间不同的想法。作为开发者你的工作不只是写你认为容易的代码， 同时也要让其他人容易理解。&#xA;2.2 Symptoms of complexity &amp;lt;复杂性的特征&amp;gt; Change amplification&amp;lt;变更放大&amp;gt; 有时候看上去是做一个小的改变，但是需要修改多处代码（功能散落在多处）。好设计的目标是降低每个设计中受影响的代码量。&#xA;Cognitive load&amp;lt;认知负载&amp;gt; 高认知负载意味着开发人员需要花更多的时间去理解需求，这会导致产生BUG的风险，因为他们很容易遗漏一些重要的信息。&#xA;作者用C语言分配内存函数举了一个例子，方法调用方需要自己关心内存释放。&#xA;系统设计师有时候用代码行数来衡量复杂性，代码行数与复杂度并无关系，有时候用更多的代码去实现，也许才是更简单的方式，因为它降低了认知负载。&#xA;Unknown unknowns&amp;lt;未知且不确定&amp;gt;&#xA;没人能够在一个不清楚来龙去脉的系统中完成开发任务，系统中太多不确定性关联，你无法定义自己应该了解到何种程度。&#xA;2.3 Causes of complexity &amp;lt;复杂性的原因&amp;gt; 复杂性由依赖和含糊不清导致。&#xA;依赖是软件的基础部分并不能完全消除，实际上依赖贯穿整个软件设计过程，但是软件设计的一个重要的目标是降低依赖，使依赖尽可能地简单。&#xA;很多时候，一个需要大量文档的系统通常是晦涩难懂的，说明它的设计不清晰，好的设计结果往往只需要少量文档。&#xA;2.5 Complexity is incremental &amp;lt;复杂性的增长&amp;gt; 复杂性在系统中是一个变量，它随着功能一起增长，当它积累到一定程度的时候，将会失去控制很难被消除，所以对于复杂性的增长要“零容忍”。&#xA;3. Working Code isn&amp;rsquo;t Enough &amp;lt;能够工作的代码是不够的&amp;gt; 3.</description>
    </item>
    <item>
      <title>2021</title>
      <link>//localhost:1313/post/2021-12-28-2021/</link>
      <pubDate>Tue, 28 Dec 2021 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2021-12-28-2021/</guid>
      <description>歌与诗 2021年12月26日，歌手刘森出了一首新歌:《和小葛去石家庄》&#xA;你已不满只是在楼下喝几杯小酒&#xA;我多加的那盘小毛豆 你也觉得不太够&#xA;感叹世界乱成一锅粥 更没人懂你那些烦忧&#xA;&amp;hellip;&#xA;轮回的叛逆太古老 过客忘不掉的每一场晚秋&#xA;刘森将一些当代诗人的诗歌，经过编曲加入音乐后发布了一张专辑《雨 RAIN RAIN RAIN》，每首诗的背后都有心酸的故事。&#xA;谁曾想到诗歌时运不济，远不如音乐通过点头就能让人释放内啡肽，变得极其小众，没有上头条的故事更不入流。&#xA;诗人 接着说关于诗的诗人，诗歌本来已经很小众了，那么谁还去在乎写诗的诗人呢。&#xA;真还有这样一位让人挂念死活的诗人，他就是张子选。&#xA;在媒体平台还不成熟的年代，张子选通过一些网络渠道，以及后来的微博零星发布他的诗作，&#xA;一直没有出版过诗集，为了读到他的正式出版诗歌，我买了一套《当代诗人十二家》，里面精选了他的几首诗。&#xA;有幸张子选还活着，2021年2月终于出版了《藏地诗篇》，豆瓣上有人评论这本书的编辑最大的败笔就是让大冰写序，这本书基本上收录了作者在藏区的所有诗作，大家再也不用在网上到处去搜罗了。&#xA;&amp;hellip;&amp;hellip;&#xA;倘若将来某日，你也因某种际遇偶然至此&#xA;陌生人，请帮忙照顾好这个世界，和你自己 &amp;mdash;&amp;mdash; 在世间&#xA;&amp;hellip;&amp;hellip;&#xA;怎么办？知道你在牧羊，不知你在哪座山上&#xA;怎么办？知道你在世上，不知你在哪条路上 &amp;mdash;&amp;mdash; 怎么办《牧羊姑娘》&#xA;在没有读到张子选之前，未曾见过将人与这个世间的距离感写得如此深切，充满力量。&#xA;工作 工作时间越长，越来越意识到工作带给人的价值。&#xA;换工作并不容易，有时候也并非顺理成章，我还是觉得《不要急于奔赴未来，未来总会如期而至》。&#xA;摩托车 每个男人都有自己喜欢的玩具，摩托车引擎的声音对我有很大的吸引力，本田CB400F作为合资里面的第一台双缸车，我等了至少两年，然后又经历半年的预定到交车，最后还是终于骑上了。&#xA;被摩托车上的风吹过，你才会对那些不被空间束缚的日子充满无限向往，我们渴望长出翅膀，并不是为了飞翔，而是为了摆脱束缚。&#xA;念旧 外地出差，在赶往机场回成都的路上，酒店的人打电话来问我遗忘的衣服是否还需要，才想起落下了一件衬衣。&#xA;那件衣服是大学一年级在真维斯买的格子衫，它不经意走过了快二十个春秋，最后却以这种方式结束。&#xA;喜新才能念旧，新的总有一天会变旧，旧是人与物件之间的一种关系，念是放不下又不想割舍。&#xA;这些年穿衣开始追求功能属性，比如喜欢上原色牛仔裤，我是最近几年才知道这种穿衣界的亚文化。牛仔裤皮实耐穿才是它诞生的目的，至于审美感都是时代的产物，今天叫意识超前，明天就是昨日复古。&#xA;所以把时间花在纠结审美上，只是另外一种消磨人生的方式，和看手机刷视频并没有不同。&#xA;故事 “ 前几天，病房来了一位阿姨，一看就知道是广东乡下农妇，不太会普通话，其他病人聊天，她在一旁听着，有点害羞也不加入，&#xA;第二天，医生通知她隔天做手术，当天下午晚饭，她鼓起好大勇气告诉大家，说她好害怕，&#xA;那天晚上她一直在病房旁边的厕所洗衣服，洗到大半夜，他儿子的衣服洗了好几遍，病友听到她一边洗一边在哭，一直到凌晨。&#xA;但是病友没有嫌弃她很吵，因为她担心明天的手术可能会让她起不来，&#xA;后来她的手术很成功。”&#xA;这是从豆瓣上看到的一个故事，短小却充满人情温暖。&#xA;故事来源于生活，高于生活，尝试用最短的字句来记录故事。</description>
    </item>
    <item>
      <title>翻越了这座山，你有没有遇到过自己</title>
      <link>//localhost:1313/post/2021-12-10-meet-yourself/</link>
      <pubDate>Fri, 10 Dec 2021 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2021-12-10-meet-yourself/</guid>
      <description>一 2003年，向北出川，翻越秦岭，&#xA;绿皮火车走走停停，对于没有出过川的人来说，那是一段极其漫长的路程。&#xA;虽都是外出谋生，但北上和南下的两类人，有着截然不同的面容和心境，我正好是南下过，又将北上的人。&#xA;车厢里大包小包的行李总比人多， 座位永远不够人坐，嘈杂声此起彼伏，狭小的车厢挤满了被麻袋包裹的灵魂， 空气里弥漫着大江南北小吃怪味，酒后鼾声盖过列车撕裂的吼声，叫卖声一轮接一轮。&#xA;被困在车厢里的人心想着何时翻过秦岭，每当有远山掠过车窗，总以为那就是了，那种迫切毫无理由但又合理。&#xA;秦岭是山，我却从没见过，也未曾怀念过，即便从它身体里穿流过数次，就像山间沟壑里奔腾后又干涸的河流，山还在，人已东去。&#xA;从那以后，我认为没有不能翻越的山，却轻视了它凶如猛兽。&#xA;二 川东丘陵连绵不断，山峦屏障起伏迭起，翻越并不容易，山高沟夹且深邃而有力，我在初中时曾有体会，切莫在山中独行。&#xA;翻山越岭赴约，临别前同乡告诉我，倘若听到山中有人在呼喊，且莫慌，一定记得回应两声。&#xA;后来听多了，才搞懂“喊山”原来是一种地方文化，一是壮胆，二是对山说：与你同在。&#xA;回应两声，一声给高山，一声给自己。&#xA;三 如今，山在那里被翻越了，却忘了呼喊，还把自己留在了山中。</description>
    </item>
    <item>
      <title>图表即代码</title>
      <link>//localhost:1313/post/2021-11-22-diagrams-as-code/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2021-11-22-diagrams-as-code/</guid>
      <description>为何要用文本的方式记录 最近工作中开始重度使用PlantUML，于是就总结一下软件开发中使用到的画图软件，以及如何在文档中嵌入图表。&#xA;软件开发时用到画图软件林林总总，差异化较大，但我们使用的大部分画图工具，都以独特的二进制文件存储，缺点不利于团队协作和分享，导致跟随代码的相关思维图不能更好地被管理，甚至无法与代码保持及时更新迭代，所以软件工程师们更希望通过像代码一样来管理图形化思维。&#xA;文本具有以下优点：&#xA;容易阅读（文本的优势） 版本管理（借助版本管理软件git） 易于编辑（任何文本编辑器） PlantUML PlantUML就是为以上这些优点存在的，它允许你通过一个简单的描述性语言（类似伪代码）来画UML图，最后通过graphviz生成图片格式（PNG，SVG）。当然PlantUML不仅仅支持UML图，还支持很多非UML图，几乎涵盖了软件开发所有标准图形，具体可以看官网介绍。&#xA;PlantUML扩展了很多语法来定义元素的的形状和属性，以及元素间的位置关系，整体布局（从上至下，或从左至右）顺序。刚开始使用PlantUML你肯定会感到不适，它不像图形化界面拖拽软件那样简单，但是作为软件开发工程师来说，学习PlantUML语法并不是难事，因为它已经做了简单化。&#xA;插件与平台支持 目前在两大主流编辑器VSCode和IDEA都有对应的插件（依赖graphviz），个人非常推荐VSCode。&#xA;由于PlantUML的普及，各大SaaS软件平台都支持将PlantUML代码嵌入到文档中（例如Confluence），直接生成图片，真正做到图形与文档同步。&#xA;C4 在工作中，很多软件工程师由于经验的不同，在表达非UML范畴的图形时，堆砌了很多线条和框图，并没有章法，鉴于这种乱象，Simon Brown 提出了 C4模型，他定义了标准化的软件架构图表达方式，将软件架构图由远及近，由粗到细，分为了4个层级：&#xA;上下文关系 容器 组件 代码 在UML基础上提出了更高层的抽象来描述软件架构。&#xA;原话是:&#xA;It&amp;#39;s a way to create maps of your code, at various levels of detail, in the same way you would use something like Google Maps to zoom in and out of an area you are interested in. 这种方法就像是地图软件上使用缩放功能一样来观察软件系统。&#xA;C4同时提供了一套基于PlantUML的模型定义，效果图如下：&#xA;PlantUML之外 Diagrams 相较于Diagrams，国内开发者用得最多的是ProcessOn，后者主要是商业化收费，在线协作存储，前者代码开源，提供本地桌面版本(主要开发语言是JavaScript)， 这类工具都提供拖拽的方式来绘制图形，支持导出图片，另外Diagrams存储的文件虽然是XML格式，但是也只有它自己的程序才能解析。&#xA;效果如下： Excalidraw 像Diagrams这些工具，并不是没有竞争对手，Excalidraw就是其中一个， PlantUML与C4模型构建了图形化的标准，但有时候我们又希望带点随性，更灵活地表达头脑风暴，Excalidraw这个工具提供了手绘风格样式，同时也支持外部导入样式。 Excalidraw也是代码开源,主要采用TypeScript语言开发，本质上和Diagrams的区别在于自由的模版风格。</description>
    </item>
    <item>
      <title>不要急于奔赴未来，未来总会如期而至</title>
      <link>//localhost:1313/post/2021-09-30-i-am-quit/</link>
      <pubDate>Thu, 30 Sep 2021 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2021-09-30-i-am-quit/</guid>
      <description>在京东工作的第9个年头，我决定离职，这并不是一个艰难的决定。&#xA;回首过往，很难相信在这里待了如此长的时间。&#xA;至今还记得刚来成都的样子，&#xA;阴冷的天空，&#xA;夹杂火锅味儿的雾霾，&#xA;当然也有冬日暖阳下的欣喜若狂。&#xA;&amp;hellip;&amp;hellip;&#xA;一 那时成都还只有一条地铁线，洛带古镇还没有人山人海，三圣乡还有很多路边小吃摊。&#xA;三月四月，青城后山听雨，吃肉，喝酒，&#xA;五月六月，五凤溪看山，&#xA;七月八月，龙泉湖野游，&#xA;到了九月就天天计划十月国庆节，最后在豆瓣约网友去了趟稻城亚丁，四川美景在川西，川西美景在亚丁，去亚丁的路上最让人神往。&#xA;十一月，葛仙山赏银杏，&#xA;运气不好，十二月就只能吸霾了。&#xA;如今总会感叹成都变化太快，网络过于发达，日子却变得太紧，&#xA;引用前独立音乐网站落网的Slogan：“落在低处”，生活会给你一切快乐，只要你愿意落在低处。&#xA;我是候鸟，永远追逐春天，奈何春天又太短。&#xA;二 很多人认为，成长是一个线性增长的过程，从初中，高中，大学，最后到参加工作，你从一个阶段到另外一个阶段，学到更多知识，获得了更多的处事经验，这些过程最后形成了自己的世界观和价值观。&#xA;但我认为成长并不是一直处于线性增长，在你获取到基本的知识，到能够形成自我认知后，成长就不是线性的了，你的判断可能在某个时间点上是正确或者错误的，它可能并不来自于你过往的经验，所以承认认知的局限性是成长的重要标志。&#xA;我们依赖某种原则来做事，那什么才是值得坚持的信仰呢？&#xA;很多年前读了罗永浩的那本《我的奋斗》，虽然这本书讲了很多罗永浩的段子，但是他讲的其中一个道理至今还影响着我，大意是:&#xA;我们每个人注定是要改变这个世界的，&#xA;今天你努力一点点，就让这个世界上努力的人多了一点点，&#xA;今天你去抢劫了银行，就让这个世界上抢劫银行的人多了一点点，&#xA;今天你孝顺了父母，就让这个世界上孝顺的人多了一点点，&#xA;今天你懒惰一点，就让这个世界上懒惰的人多了一点点，&#xA;&amp;hellip;&amp;hellip;&#xA;这种论点要是放到今天，很多人认为这是典型的鸡汤，可是有些鸡汤是经不起推理的，我相信个体和这个世界存在某种关联，并相互影响。这一观点让我得到了成长，前所未有的顿悟，我们注定是要被世界改变的，就像我们改变世界那样。&#xA;过去几年，我总是期待生活能时常带来这些启发，去主动思考，不论是来自于阅读，工作，还是生活中每个细微的事件，都能让我从过往中获得新的认识，但生活并不总能给你这些馈赠。&#xA;很长一段时间里，我在工作中一直处于孤岛状态，没有互动，或者说工作已经不能让我和其他人一样，看上去“全力以赴”的样子，工作变成了煎熬。不是工作本身发生了变化，是我没有在工作中寻找到意义。&#xA;万物遵循自然，只有人类才会追求意义。&#xA;成长就是一个寻求意义的过程。&#xA;三 在工作上，我一直认为自己是一名工程师，通过努力让自己变得更出色，以适应当前工作的需要，尽其所能帮助他人。&#xA;我们一生中至少有一半的时间都在工作，非常有必要理解何为工作，为何而工作，如何看待工作。&#xA;Paul Graham在2006年写过一篇长文叫How to Do What You Love，这篇文章影响了很多人，他还写了很多有深度的文章，只可惜我读得太晚，未能更早领会其中的奥义。&#xA;你要忍受当前工作的不适应，更要为自己想做的事情做准备。&#xA;没有一份工作是让你感到愉悦的，或者说让你一直感到愉悦的工作并不存在，现实总是这样，这很容易让人产生扭曲的心理，你坚持工作下去的唯一理由可能只剩下：我需要钱。人在组织中总是要找到一个价值存在感，有存在感同时被认可，但这些和热爱工作无关。人天生就好逸恶劳，唯有热爱才能激发行动。&#xA;四 西岭寒窗千秋雪，为何今日离别忙。&#xA;这个国庆过后，我拥有了一台本田CB400F，按计划离开京东后骑行一趟西藏，正如所料，时间，地点，人物都没有万事俱备，只能期待未来。&#xA;“是谁来自山川湖海，却又囿于昼夜，厨房与爱”&#xA;感谢过往的一切，活在当下。&#xA;不要急于奔赴未来，未来总会如期而至。</description>
    </item>
    <item>
      <title>不确定性</title>
      <link>//localhost:1313/post/2020-10-22-indeterminacy/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2020-10-22-indeterminacy/</guid>
      <description>这个世界有没有看起来是确定的事情？&#xA;可能没有，&#xA;不确定才是这个世界最值得探索的奥秘。&#xA;但如果非要让一件事情变得更接近确定，那么有没有一套经得住考验的方法论呢？&#xA;这还真有，&#xA;科学家在探索自然的过程中总结了以下的方法：&#xA;仔细观察真实世界，并得到精确的测量数据； 根据观察结果提出假设模型； 根据模型预测未来的事件； 继续观察并核实预测的准确性； 如此反复直到确认预测和观察一致； 不要小看这个方法体系，常人要把每一步都做好是非常难的。&#xA;观察真实世界 真实世界不会说谎，但也不会主动告诉你真相，有时候你看到的世界并不是真实的，我们大部分时候只是活在一个自我假设的世界里。&#xA;科普图书《时间的形状》中讲了一个高速列车杀人事件的故事，来让大家理解时间和惯性系的问题，就是非常典型的例子。&#xA;我在生活中也遇到过类似需要理解时间的例子，如何设计一个促销系统，当系统A中的促销生效时通知B系统。当和产品经理讨论这个问题时，我无奈地告诉他，这是一个哲学问题。因为这里的时间是一个事件的结果，不能产生行为。正如《Time, Clocks and the Ordering of Events in a Distributed System》论文描述的那样，时间在不同空间中是隔离的，所以要在分布式系统中传递事件，同时还要保证事件的因果关系，这就是一个难点。&#xA;如果观察不具备完整性，也很难说明观察结果是准确的，比如在没有把天下所有的乌鸦都看一遍，你无法得出结论：天下的乌鸦都是黑的。&#xA;提出假设模型 有了观察数据，我们往往能从数据中找到一些规律，然后利用数学知识来定义，为什么是数学呢？因为数学具备推理和逻辑性。&#xA;例如：a大于b,同时b大于c，那么a一定大于c。&#xA;我们无法推翻这种原子级的认知逻辑，所以这种工具可以不用上面提到的方法来验证其正确性。&#xA;就像计算机系统优化一样，你不能直觉上提升某个或者几个组件的性能，从而得出整体性能提升的结论。至少要有类似Amdahl&amp;rsquo;s law（阿姆达尔定律）这样的模型作为指导。&#xA;预测未来 为了验证模型的正确性，所以利用模型预测未来事件就是符合逻辑的做法。因为非预测事件一旦发生就证伪了模型。就像上面说的，只要有一天出现了一只白色的乌鸦，那么天下乌鸦都是黑的结论立刻被推翻。&#xA;科学的不确定性 你会发现上面提到的科学方法，更多地是收集数据来证明预测的准确性。由于世界有太多未知，所以就像物理学家理查德·费曼说的那样：科学的不确定性源于我们对世界的无知。</description>
    </item>
    <item>
      <title>计算机多内核平台上的并发锁优化(二)</title>
      <link>//localhost:1313/post/2020-08-21-locks-on-multicore2/</link>
      <pubDate>Fri, 21 Aug 2020 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2020-08-21-locks-on-multicore2/</guid>
      <description>申明: 大部分内容来源于网络，我不生产知识，我只是字符串搬运工。&#xA;在Algorithms for scalable synchronization on shared-memory multiprocessors这篇论文中，CLH锁之前还提到了另外一个锁算法。&#xA;凭证锁(The Ticket Lock) 这个算法也很形象，比如你去10元快剪理发(假设只有一个理发师)，你得先买票，出票机在出票的时候，会显示前面还有几位在等待，你需要等待多久呢？&#xA;假设一个人理发需要10分钟，如果你前面有两人，那么你就要等20分钟。&#xA;凭证锁有两个变量，一个表示当前服务的凭证，另外一个是下一个将被服务的凭证。&#xA;实现如下:&#xA;public class TicketLock { private final AtomicLong nextTicket = new AtomicLong(0); private final AtomicLong nowServing = new AtomicLong(0); public void lock() { long myTicket = nextTicket.getAndIncrement(); while (true) { //只为了表达算法，没catch异常 Thread.sleep(myTicket - nowServing.get()); if (nowServing.get() == myTicket) { return; } } } public void unlock() { nowServing.incrementAndGet(); } } 凭证锁在test_and_set锁的基础上，其实也是做到了FIFO的公平性，而且不会有饥饿的情况。&#xA;凭证锁相当于用事件计数和序号实现的信号量。&#xA;这种锁的缺点也很明显，需要循环读取nowServing变量，在多核CPU多级缓存架构下，同时读取共享变量，会带来大量的内存和带宽竞争，虽然sleep降低了内核之间的连续竞争,但随着获取锁的内核数量增加，会导致Exponential backoff。</description>
    </item>
    <item>
      <title>计算机多内核平台上的并发锁优化(一)</title>
      <link>//localhost:1313/post/2020-08-19-locks-on-multicore/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2020-08-19-locks-on-multicore/</guid>
      <description>申明: 大部分内容来源于网络，我不生产知识，我只是字符串搬运工。&#xA;如何在高并发的情况下，提高多核CPU的性能，一直是在并发编程领域中非常重要的问题。 特别是随着云厂商按计算收费的当下，如何有效地利用计算资源变得更重要。&#xA;致富的途径只有两种：一种是拼命赚钱，另外一种就是有钱后节约花钱。&#xA;什么是锁 在计算机硬件层其实是没有锁这个概念的，计算机领域中的锁来源于现实生活中的锁，它的作用是保护某种资源同一时间不能被多人访问。现代计算机已经发展成了多核CPU处理器，我们需要通过锁机制来协调多个内核对资源的访问操作。&#xA;和现实中一样，在给资源上锁的时候，我们可能需要几个步骤：&#xA;拿出钥匙 锁上资源 解锁 计算机中对应的CPU操作就是执行几条指令(CPU每条执行指令都是原子级别的操作，要么成功，要么失败，这是二进制世界的规则)。&#xA;这里罗列几条与后面要讲到的锁相关的硬件同步汇编指令&#xA;test_and_set swap get_and_add test_and_set 由3条CPU原语组成&#xA;​ boolean test_and_set(*lock){ ​ boolean old=*lock; ​ *lock=true; ​ return old; } BTS 指令含义是在执行 BT 命令的同时, 把操作数的指定位置为 1&#xA;do{ //当*lock为false是跳出该循环 while(test_and_set(*lock)); critical section;//访问临界区 *lock=false; }while(true) swap也是由三条CPU原语组成: BSWAP指令含义是：把32/64位寄存器的值按照低和高的字节交换(下面代码实现其实就是0=false,1=true交换)&#xA;void swap(boolean *a,boolean *b){ boolean temp=*a; *a=*b; *b=temp; } do{ key=true; do{ swap(&amp;amp;lock,&amp;amp;key); }while(key) //上面初值为false cirtical section//访问临界资源 lock=false; }while(true) 上面简要地说明了通过CPU硬件同步原语，对某个内存地址标志位的修改，起到加锁的作用。&#xA;那么锁机制和性能有什么关系呢？这得从内存(Memory)，CPU缓存说起。&#xA;多核CPU多级缓存架构 早期的CPU架构基本上都采用SMP(Symmetric Multi-Processor)，这种对称多处理器结构，多个CPU内核共享内存资源，除了内存速度访问慢以外， 还可能导致访问冲突。</description>
    </item>
    <item>
      <title>不可测试的代码</title>
      <link>//localhost:1313/post/2020-01-21-untestable-code/</link>
      <pubDate>Tue, 21 Jan 2020 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2020-01-21-untestable-code/</guid>
      <description>故事是这样的，我最近深陷在一个刚接手不久的项目中，经过完成两轮需求上线后， 我迫切地告诉自己，需要给这个项目完善一下测试用例（原工程测试用例几乎为零）， 然而事情并不是我想象的那么简单。&#xA;经过两天给项目引入EasyMock，Jmockit相关测试框架，最终我还是没有完成对其中一个任务Job的测试代码。虽然结果不如我的预期，但这种挫败感反而让我平静，让我思索这一切为何反复发生，像一部递归的电影。&#xA;现实就是，大部分程序员在其职业生涯中，半数以上的时间都是工作在别人的代码之上的。&#xA;相对于写出不可阅读的代码，写出不可测试的代码的情况更常见。&#xA;究其原因，问题还是出在测试上。&#xA;通过对相关参考书籍走马观花的阅读，我总结了以下两点书中未提及的现象。&#xA;纠正认知 在日常生活中，我们作出很多行为，并不需要考虑一个问题：如何测试行为结果是否符合预期？所以我们基本不会把生活中的未知结果，定义为不可测试。&#xA;另外一个现实是，我们进入程序员这个行业的时候，首先学会的是如何利用工具创造（软件开发），然后才衍生出如何测试。创造和测试作为两个完全独立的部分被认知，结果就是我们花更多的时间在创造上。&#xA;如今软件工程越来越庞大，业务领域越来越复杂，所以如果要将软件开发分解成创造和测试两个部分的话，我觉得在他们各自的投入上应该是五五开。&#xA;我看到的很多工程都是在完成需求上花的时间比测试更多，虽然他们声称测试很重要。&#xA;如果整个软件构建链条上的所有人员达成了共识，那么就可以借助相关的技术来完成任务。&#xA;保持风格统一 让我们再回到代码工程中，软件开发就像写作，你可以在一定的原则下完成创作，既然是创作就有风格问题。&#xA;多人协作的项目里，很容易留下开发人员的风格，所以很多团队推出了自己的工程规范，以及代码规范，比如Google Java Style Guide，尽管这些开发人员熟读了《重构 改善既有代码的设计（第2版 ）》这样经典的指导书籍，但风格问题还是会在项目中出现。&#xA;当你加入一个项目时，首先要弄清现有工程的风格是什么样的，在重构的过程中尽量避免破坏好的风格，引入自己独特的风格。&#xA;总结 回到我的故事，我属于进攻型编程人员，在面对不可测试的的代码时，会让情况变得更糟糕，所以还是反复确认了几个原则:&#xA;能工作的代码，就尽量不要改善它。 在有单元测试的情况下，最小单元修改。 不写代码，就不会有BUG。 最后总结：术可以学习，但道却需要领悟。&#xA;&amp;mdash;&amp;mdash; 我是分割线 &amp;mdash;&amp;mdash;&#xA;下面的相关书籍，在开发，测试，重构方面提供了很好指导，值得仔细反复阅读。&#xA;Unmaintainable Code 重构 改善既有代码的设计（第2版 ） Work Effectively With Legacy Code Growing Object-Oriented Software, Guided by Tests Understand Legacy Code </description>
    </item>
    <item>
      <title>对技术招聘的一些启发</title>
      <link>//localhost:1313/post/2019-12-28-heuristics-for-hiring/</link>
      <pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2019-12-28-heuristics-for-hiring/</guid>
      <description>国外一家自由职业招聘平台 Gun.io ，最近针对问题“当招聘高级工程师时最看中哪些方面？”，采访了38名CTO， 最后出了一份报告。&#xA;在招聘开发工程师上，国内很多大厂在面试的时候，基本上都是先通过算法来考察候选人，过分强调算法这一部分的功力，导致很多人打趣的说，现在面试都已经 内卷起来了，没刷够几百道Leetcode题都不好出去面试。这充分说明了算法在软件开发中的重要性。&#xA;招聘对企业或者团队来说其实也带有一定风险，因为很难通过招聘来判断人的长期价值。很多企业基本上都是着眼于当前，满足目前需求即是合适的。&#xA;当然判断一位工程师是否出色，肯定还有其他方面可以挖掘。这份报告总结了以下几个方面:&#xA;出色工程师的基因 1. 对技术的投入 在所有的答案中我们听得最多的就是“对技术的投入”。&#xA;技术领导人希望工程师们在技术和非技术领域，都保持高昂的热情和持续学习的心态。&#xA;“不仅仅是学习下一个新技术，也必须适应软件工程的变化和不同种类的技术栈”&#xA;-Christine Spang, Founder &amp;amp; CTO of Nylas&#xA;那些通过持续学习新技术来改进他们工作的工程师，对一个长远发展的团队来说是非常有价值的成员，就是成为一个持续学习者。&#xA;对“不知道”说“我可以” “特殊的开发人员在解决未知领域问题时显得非常自信，他们并不担心他们是否知道所有技术,他们享受探索和学习的乐趣。”&#xA;-Kelly Stevens, VP of Engineering of OneSpce&#xA;就算一名有7到10年工作经验的工程师，并不意味着他们什么都知道，一个出色的工程师无论他拥有多少技能，仍然应该对“不知道”感到高兴。&#xA;为什么？&#xA;在某个阶段，没人什么事情都知道。 出色的领导会说“不知道”。 未知给好奇心和激情留下了施展空间。 启示: 招聘愿意试一试的人，而不是什么都知道的人。&#xA;2.软技能 从前开发人员工作不需要很好的交流技巧，大部分工作就是准时打卡上班，不需要和任何人交流，按时完成工作就可以了。&#xA;但现在，这样的日子一去不复返，我们需要赢得客户的共鸣，我们需要清晰地表达架构选择背后的逻辑，我们需要与参与人建立良好的关系，推进工作。&#xA;我们叫这些为软技能，但这些都是真正的专业技能，出色的开发人员必须具备这些。&#xA;“如何通过交流将你的技术能力和解决方案建议给别人，如何传达这些信息非常重要。”&#xA;-Shawn Kuenzler, Co-founder &amp;amp; CTO of Manatee&#xA;对高级工程师来说应该如何交流呢？&#xA;能够清晰地向每个人表达解决过程和方案（技术和非技术）。 能够简明扼要地表达对项目的意见和想法，以及如何才能做的更好。 定期向管理人员，参与人以及客户分享项目达到的里程碑。 交流的艺术 “我曾看到那些在解决问题上很在行，但很难交流的工程师，&#xA;工程师需要交流，以便在解决问题的过程中成长。&amp;quot;&#xA;-Rahul Garg, SVP of Engineering at Pypestream&#xA;交流不仅仅发生在和客户之间，更多的是团队内部。&#xA;问题思考:&#xA;是否在遇到问题的时候向团队其他成员寻求帮助？ 是否与其他工程师协同完成项目？ 是否定期(按日，周，月)根据好的反馈作出调整？ 启示: 交流是提升生产效率，质量和执行的关键所在。</description>
    </item>
    <item>
      <title>2019阅读清单</title>
      <link>//localhost:1313/post/2019-reading-list/</link>
      <pubDate>Wed, 25 Dec 2019 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2019-reading-list/</guid>
      <description>人们经常说这个时代物欲横流，信息爆炸，有人自带优越感，有人贩卖焦虑&amp;hellip;&amp;hellip;&#xA;但无论如何，这都不是你看到的那个世界，唯有当你探索未知时，才是真实。&#xA;2019年的阅读重点是自我认知，所以读了一些关于个人成长的书籍。&#xA;这些书籍大致分为三类:&#xA;1.情绪驱动 (当你正在用所谓的理性分析这个世界时，那也是一种情绪驱动)&#xA;2.养成习惯 (大脑形成习惯，是为了懒惰，为了让我们降低思索的能耗)&#xA;3.正常沟通 (只有能控制情绪的人，才能更好地沟通)&#xA;《如何养育女孩》&#xA;我有一个女儿，作为父亲我没有什么经验，所以把责任这个词有时候理解太简单，养育下一代其实也是自我成长的一个契机，因为自己变成了家庭层次中那个重要的枢纽。这本书将养育男孩和女孩区分开来(作者还有一本《如何养育男孩》)，将养育过程分成了几个阶段，书中在很多段落都加入了一些测试，用来提醒读者判断自己当前的状态，更重要的是作者反复提醒读者错过的事情你还有机会弥补,这本书作为一本方向性指南，还是非常有阅读价值，特别像我这种早期家庭教育有缺陷的人。&#xA;《你要如何衡量你的人生》&#xA;我们每个人的人生都不一样，那是因为我们对生活的本质理解不一样，有时候也许只是选择不同，结果并没有对错，因为只有你自己能对选择负责，别人代替不了。&#xA;《优秀到不能被忽视》&#xA;相较于找一份热爱的工作,找一份工作然后爱上它更容易实现。&#xA;当你工作迷茫的时候，这本书里一定有你的解药。&#xA;《请停止无效努力》&#xA;这本书和其他鸡汤类书籍不同在于作者提出了明确的自我剖析方法。&#xA;在这种框架下做自我拓展，看了每个章节的标题觉得都不想错过内容。(因为你很焦虑)&#xA;《深度工作》&#xA;我相信现在很少有人进入某种状态而忘记周围的世界，或者说这种状态能够持续足够长。想想你正刷着抖音， 刚进入那种娱乐高潮时，下一秒不由自主地想到的就是将它分享到社交平台。 这本书告诉你，为何你不能深度工作，深度工作是如何重要，你应该如何做到深度工作。&#xA;《情商（全六册）》&#xA;很多观点你在生活中或多或少都听过，我不清楚是否都来自于这种书籍，但至少可以确定，很多内容已经变成了常识。 但要消化完整套书，还是需要很多时间来实践。&#xA;《强势谈判》&#xA;我认为大部分人利用语言只做三件事:日常沟通，花言巧语，另外一种就是谈判，作为读者你基本上遇不到像作者那样面对恐怖份子谈判的机会，但谈判的核心要素却是相通的。作为FBI谈判专家的建议，在生活中还是很有实用价值，作者特别强调在利用谈判技巧前，理解对方真实感受才是最重要的。&#xA;《掌控习惯》 &amp;amp; 《习惯的力量》&#xA;这两本书放在一起算是姊妹篇。&#xA;《习惯的力量》主要讲习惯是如何产生的，它对我们生活有哪些影响，书中讲了一个梦中 杀妻的案例，最后凶手被无罪释放，阐述了习惯的力量。&#xA;相比较而言《掌控习惯》主要从习惯产生的几个条件入手，总结了一套戒掉坏习惯养成好习惯的方法。&#xA;《经济学的思维方式》&#xA;本书开篇对经济学做了一个定义:&#xA;经济学是研究具有不同用途的稀缺资源的使用问题&#xA;从这一点就可以看出，经济学与我们很多生活上的决策是有关系的，但书中举了很多反例都是苏联时期的，虽然不影响理解，但总觉得怪怪的。&#xA;《图解算法》&#xA;因为这本书篇幅不长，这是今年唯一读完的技术类书籍。正如作者说的那样，我是一个视觉型学习者，作者将算法结合画图的形式进行讲解，确实有很好的效果。&#xA;但想要在数据结构和算法上精进，尽量配合其他同类书籍，比如《算法》。&#xA;当代诗人十二家&#xA;《当我终于变得沉默:当代诗人十二家》&#xA;《在夜晚的高原上:当代诗人十二家》&#xA;《落在纸上的雪:当代诗人十二家》&#xA;就像这本书的作者说的那样，诗歌在这个信息时代已经沦为了少数派，&#xA;这个系列图书是献给我们中的少数人的。&#xA;诗歌是情感与文字交融的结晶，透过文字与作者相遇，也是情绪训练的一种方式。&#xA;总结 今年还读了一些别人推荐的好书，比如《原则》，这类书籍阅读起来非常苦难，因为作者的每一条经验总结都付出了很多实践和探索，资历浅是很难完全领悟的。&#xA;所以2020年需要减少盲目阅读，同时将阅读面扩大到小说类，按月份列出阅读清单。</description>
    </item>
    <item>
      <title>执命向西的人</title>
      <link>//localhost:1313/post/2019-12-05-follow-your-heart/</link>
      <pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2019-12-05-follow-your-heart/</guid>
      <description>老婆自行车环游大半个中国回来后的那段日子，我无意中听到一首歌《一个西藏》&#xA;一座高原&#xA;一个西藏&#xA;……&#xA;我和世界只有一个西藏&#xA;我没有去过西藏，所以对西藏并没有特殊的情感，但从那时起知道了一位诗人:张子选。&#xA;至于西部，我最多去过川西的边境。&#xA;无意中，我还是和朋友约了将来骑摩托车去西藏，&#xA;可惜这一句将来，一直还没来。&#xA;宋冬野说:&#xA;爱上一匹野马， 可我的家里没有草原&#xA;现在的我满眼都是草原，却少了一匹马。&#xA;执命向西的人，终究还是离那个西，很远。&#xA;前段时间，在网上淘了一本张子选的《执命向西》 才明白，&#xA;执命的人是命中注定。&#xA;&amp;hellip;&amp;hellip;&#xA;我之所以有时哭泣&#xA;是因为百世轮回中 你我之间常常隔着茫茫人世&#xA;&amp;hellip;&amp;hellip;&#xA;两厢不情愿的人在一起，才是执命。&#xA;我有时候讨厌诗歌，但又必须回答一个问题，&#xA;什么是诗歌？&#xA;我想，有一些文字打在你心上，让你说不出话来的时候，那就是诗歌。&#xA;有一次，老婆带我去参加她朋友咖啡店分享骑车旅行的体验，&#xA;向我提问的时候，我自然是没有话语权，我只是尽量做到不要对有方向的人太多阻挠，&#xA;在听众看来，那是一种不可思议的行为。&#xA;后来那段分享被收录到朋友出版的那本《不上班的理想生活》书里。&#xA;但这些和真正执命向西的人没有一点关系。</description>
    </item>
    <item>
      <title>Clojure中的数据类型</title>
      <link>//localhost:1313/post/2019-11-19-clojure-datatypes/</link>
      <pubDate>Tue, 19 Nov 2019 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2019-11-19-clojure-datatypes/</guid>
      <description>Clojure作为一款基于JVM的LISP语言，我个人从创造者Rich Hickey身上吸收了很多编程的观点，尽管作者提出了很多面向对象编程语言的缺陷，但单从语言本身来说，作者更希望通过JVM这个平台对寄主语言(Java)提供一种补充，只不过是通过LISP的方式。&#xA;封装与多态性 封装和多态性是面向对象编程语言的两大特性，松本行弘认为&#xA;面向对象的设计方法是在结构化编程对控制流程实现了结构化后，又加上了对数据的结构化&#xA;不需要知道内部的详细处理就可以进行操作(封装，数据抽象) 根据不通的数据类型自动选择适当的方法(多态性) Java利用类和接口虽然解决了很多设计问题，但是看上去还是不够优雅，比如类不能多继承，所以Clojure希望通过更彻底的方式来做到更高级的抽象。&#xA;认识Java的类 在拥有了基本的数据结构(set，vector，list，map)之后，我们就可以依赖这些基础数据结构构建我们模型，通过组合的方式来表达业务领域，在Java中是这样的：&#xA;Class User { private String name; //数据 private int age; //数据 .... public String getName(){ //行为 .... } public void setName(String name){ //行为 .... } } 但这个POJO将数据和行为交织在一起，如果在行为中没有任何业务逻辑，仅仅是暴露数据给外部，在领域驱动设计中这叫贫血对象，根据个人的经验，这样的贫血对象设计在很多Java系统都存在，同样的领域概念不能在系统中重用，想象一下，在社交系统中有User领域模型，电商系统中可能也包含一个User领域模型，但你不能重用两个系统之间完全相同的数据模型。&#xA;defprotocol 在Java里通过interface来定义行为(和Clojure的definterface是完全一致的)，一个类可以实现多个interface，子类可以重写父类的方法来实现多态。但是接口的问题是一旦被创建，就很难被扩展，Clojure的解决方案是协议defprotocol,它比接口更灵活，例如:&#xA;(defprotocol Dateable (to-ms [t])) ;定义一个包含to-ms方法的接口 (extend java.util.Date Dateable {:to-ms #(.getTime %)}) ;java.util.Date实现了这个接口 (to-ms (java.util.Date.)) ;java.util.Date具备了to-ms方法 在Java中可以通过继承或者组合的方式实现对原有类的扩展，但是会显得很笨粗，Clojure避免了不必要的多层次封装/适配，在不修改原有类同时不新增类的基础上实现了真正的多态性。defprotocol 除了可以被deftype,defrecord,reify实现外，也可以被Java中的类实现。&#xA;数据与行为分离 所以，Clojure提供更明确的方式，数据必须具有不可变性(函数式编程特性)，行为是在更搞层次抽象。推荐将数据和行为分别定义，Clojure提供了deftype，defrecord，reify, defprotocol来达到这个目的，他们就是Clojure的数据类型。defrecord用于映射你的数据记录，deftype可以理解为Java中的class，defprotocol定义行为。&#xA;defrecord defrecord在Clojure里面可以理解为是另外一种map变形方式,例如一个定义User领域模型的map为:&#xA;(def user {&amp;#34;name&amp;#34; &amp;#34;xiebiao&amp;#34; , &amp;#34;age&amp;#34; 30}) (:name user) 用defrecord来表达:</description>
    </item>
    <item>
      <title>翻译:Understanding the LMAX Disruptor</title>
      <link>//localhost:1313/post/2019-04-19-understanding-the-lmax-disruptor/</link>
      <pubDate>Fri, 19 Apr 2019 21:24:47 +0000</pubDate>
      <guid>//localhost:1313/post/2019-04-19-understanding-the-lmax-disruptor/</guid>
      <description>翻译前言 知道Disruptor这个代码库，是在Log4j 1.X升级版Log4j2中提到的，那时候就好奇它为何如此高效，关于Disruptor的文章在ifeve.com上已经有很多了，这一篇讲的更简单。&#xA;由于个人英文水平有限，更多是意译。&#xA;&amp;mdash;&amp;mdash; 我是分割线 &amp;mdash;&amp;mdash;&#xA;LMAX Disruptor 是由一家金融交易平台公司LMAX Exchange开源的Java包,它为线程间的通信问题提供了极其优雅，高效的解决方案。&#xA;在这篇博文中，我先描述关于传统排队系统在跨线程之间的内存共享问题，然后试图弄清楚LAMX Disruptor 在该问题上有什么特别方案，他们是如何做到的。&#xA;LMAX Disuptor 的解决方案比ArrayBlockingQueue和LinkedBlockingQueue要快。 Mechanical sympathy让你成为更好的开发人员。(更好地理解底层硬件) 在线程中共享内存很容易引发问题，你需要小心对待。 CPU缓存比主存更快，但是不懂得他们是如何工作的(行缓存，等等)反而会严重影响性能。 内存伪共享 举个例子，我们需要对一个计数循环递增到MAX:&#xA;public void simple() { int counter = 0; for (int i = 0; i &amp;lt; MAX; i++) { counter++; } System.out.println(&amp;#34;counter=&amp;#34; + counter); } 因为MAX值可能会很大，为了关注性能，我们决定在多核处理器上来跑这个程序，将这个任务分到两个独立的线程上执行，像这样:&#xA;public void multi() throws Exception { // First thread final Thread t1 = new Thread(() -&amp;gt; { for (int i = 0; i &amp;lt; MAX / 2; i++) { sharedCounter++; } }); // Second thread final Thread t2 = new Thread(() -&amp;gt; { for (int i = 0; i &amp;lt; MAX / 2; i++) { sharedCounter++; } }); // Start threads t1.</description>
    </item>
    <item>
      <title>读书:How Will You Measure Your Life?</title>
      <link>//localhost:1313/post/2019-02-24-how-will-you-measure-your-life/</link>
      <pubDate>Sun, 24 Feb 2019 18:24:47 +0000</pubDate>
      <guid>//localhost:1313/post/2019-02-24-how-will-you-measure-your-life/</guid>
      <description>在读到《How Will You Measure Your Life? 》 这本书之前，是看到一篇辞去亚马逊年薪500万工作的文章，大概是讲随着工作中升职，加薪，工作激情却在逐渐降低，于是就辞去了高薪工作。&#xA;在作者推文评论中有人说到了这本书，我以为这本书会讲如何提高在工作中的激情，于是就下载了电子版。&#xA;但这本书更像是一本生活指南:&#xA;要有长远规划，但也要注意短期计划，这两者是不冲突的 保持行动和目标一致 幸福的源泉很大一部分来自和家人和朋友的亲密关系 珍惜和孩子一起的时光 制定家庭文化，给孩子做榜样 关于我们生活中幸福的源泉，你首先必须回答：幸福是什么？可以看看这个TED演讲的解释,网易有中文翻译</description>
    </item>
    <item>
      <title>如何跑完半程马拉松</title>
      <link>//localhost:1313/post/2017-02-18-how-to-run-half-marathons/</link>
      <pubDate>Sat, 18 Feb 2017 18:24:47 +0000</pubDate>
      <guid>//localhost:1313/post/2017-02-18-how-to-run-half-marathons/</guid>
      <description>是的。&#xA;如果你想先喝一碗高质量鸡汤，来加强跑马拉松的决心，那么你可以读读村上春树的《当我谈跑步时,我谈些什么》。&#xA;然而我觉得那对你真正跑起来并没有什么卵用。&#xA;如果你对 马拉松 的定义还仅仅停留在跑步这个层面上，那么你是应该好好在网络上搜索一下。&#xA;首先我必须纠正一个普遍的认识误区，那就是把跑步或者跑马拉松当成获得某种利益的方式( 男的为了减肥，女的为了瘦身)。&#xA;实际上，减肥和瘦身只是跑步的副产品，它带给你的远远不止这些。&#xA;回到正题，本人只跑过半程马拉松，所以我在这里记录一下个人心得，记录在半程马拉松(21.0975公里)中每个阶段的感受。&#xA;1公里 在前1公里的时候，体内有充分的糖分，所以整个人的状态就是happy，感觉衣服上带有披风，帅帅的。&#xA;2公里 体内糖分消耗得差不多了，开始有点异样的感觉，但是一切还好。&#xA;3公里 这时候，大部分人基本上会感到开始有点不适应，身体会发出一种抵触(停下来)的信号。&#xA;4公里 拿出能量糖，来上一颗，继续。&#xA;5公里 哼，怎么感觉衣服上又有披风了，帅帅的。&#xA;6，7，8，9，10公里 在匀速的情况下，思想开小差，想想天南地北的事情(大部分是在想曾经牛逼的时刻)。&#xA;11，12，13公里 身体再次发出停下来的信号，因为心跳，呼吸开始没有节奏，疲惫的情绪愈发强烈，这时必须得上内心戏：&#xA;&amp;ldquo;是你自己要来跑的&amp;hellip;&amp;rdquo;&#xA;&amp;ldquo;说好的，要跑完&amp;hellip;&amp;rdquo;&#xA;&amp;ldquo;看看别人，那么多人都超过你了&amp;hellip;&amp;rdquo;&#xA;&amp;ldquo;&amp;hellip;&amp;rdquo;&#xA;自己对话大概五分钟。&#xA;来到14，15公里 双腿开始有点麻木，其实不用大脑发出跑步的指令，双腿已经不能停下了，但是依旧疲惫，一种强烈想停下来的感觉不能自拔，继续内心戏：&#xA;&amp;ldquo;你个垃圾玩意儿,半程都搞不定&amp;hellip;&amp;rdquo;&#xA;&amp;ldquo;垃圾玩意儿&amp;hellip;&amp;rdquo;&#xA;&amp;ldquo;你就是个垃圾&amp;hellip;&amp;rdquo;&#xA;&amp;ldquo;垃圾&amp;hellip;&amp;rdquo;&#xA;掏出一粒能量糖，继续。&#xA;16,17公里 &amp;ldquo;噫，我怎么跑了这么远了，还有5公里就到终点了, 哎哟，不错&amp;rdquo;&#xA;18公里 &amp;ldquo;加油哥们，马上你就做到了&amp;rdquo;&#xA;&amp;ldquo;哎哟，前面有两个cosplay，超过他们&amp;rdquo;&#xA;19，20公里 有很多人在加油助威，没脸停下来，继续。&#xA;终点 冲过终点那一刻，大脑里面：&#xA;&amp;ldquo;我好牛逼&amp;rdquo;&#xA;&amp;ldquo;终于他妈到了&amp;rdquo;&#xA;&amp;ldquo;我买的水在哪里来着&amp;rdquo;&#xA;&amp;ldquo;我的衣服一定有披风&amp;rdquo;&#xA;&amp;ldquo;一会儿好好自拍两张&amp;rdquo;&#xA;&amp;ldquo;哎妈，怎么觉得我是冠军呢&amp;rdquo;&#xA;总结 我相信，第一个全程马拉松，我会有很多戏份。&#xA;最后 对上面我个人感受进行整理，不难看出跑半程马拉松需要：&#xA;确认目标 自我抵抗 自我批评 内心激励 然后才是科学的方法，饮食，呼吸，跑姿，监测心率，速度控制&amp;hellip;&amp;hellip;(你可以在跑步社区或者网络找到更全的指南)。&#xA;但小部分人只学会了 确认目标 就挂了，对，就是死在了赛场上(可以浏览历年来跑死在马拉松赛场的新闻，死的原因几乎就是未解之谜)，这就是没有利用科学方法的悲哀。&#xA;如果你迟迟不能迈出 内心激励 这一步，那么对着镜子 看看你那坨放眼望去满是占尽生活便宜的身材，沉默三分钟，然后该干嘛干嘛。</description>
    </item>
    <item>
      <title>如何利用Linux命令简单加密文本</title>
      <link>//localhost:1313/post/2017-02-04-how-to-encrypt-by-linux-command/</link>
      <pubDate>Sat, 04 Feb 2017 18:24:47 +0000</pubDate>
      <guid>//localhost:1313/post/2017-02-04-how-to-encrypt-by-linux-command/</guid>
      <description>在web上无论企业还是个人网站，总会发布一些邮箱的联系方式，由于邮箱地址置于html页面中，很容易被 爬虫获取，导致邮箱被垃圾邮件挤满。&#xA;所以，如果你确定要暴露你的邮箱到互联网上，那么你至少应该使用一种加密方式。&#xA;下面介绍两种简单加密方法。&#xA;使用xxd,bc,dc命令加密解密 第一步(将文本转换为16进制):&#xA;$ echo &amp;quot;xxxxx@gmail.com&amp;quot;|xxd -ps -u&#xA;$ 787878787840676D61696C2E636F6D0A&#xA;第二步(将16进制转换为10进制):&#xA;$ echo &amp;quot;ibase=16; 787878787840676D61696C2E636F6D0A&amp;quot;|bc&#xA;$ 160132878550962084828530736251255352586&#xA;解密:&#xA;$ dc -e 160132878550962084828530736251255352586P&#xA;使用base64编码 第一步:&#xA;$ echo &amp;quot;xxxxx@gmail.com&amp;quot;|base64 -i&#xA;$ eHh4eHhAZ21haWwuY29tCg==&#xA;第二步:&#xA;$ echo &amp;quot;eHh4eHhAZ21haWwuY29tCg==&amp;quot;|base64 -d&#xA;$ xxxxx@gmail.com&#xA;总结 上面的方法只是防止人和机器直接识别出文本，并算不上真正意义上的加密。</description>
    </item>
    <item>
      <title>我们是如何将一个项目做烂的</title>
      <link>//localhost:1313/post/2016-08-08-how-to-make-projects-failed/</link>
      <pubDate>Mon, 08 Aug 2016 01:24:47 +0000</pubDate>
      <guid>//localhost:1313/post/2016-08-08-how-to-make-projects-failed/</guid>
      <description>在你读到这篇牢骚的时候，无数个项目正在慢慢变烂。&#xA;既然标题都用到了&amp;quot;烂&amp;quot;这个词，那什么才是烂呢？&#xA;在你的项目里，&amp;ldquo;烂&amp;quot;和&amp;quot;好&amp;quot;一样无法准确的衡量和定义，在大多数人的职业生涯里，你听到&amp;quot;烂&amp;quot;项目肯定比听到&amp;quot;好&amp;quot;项目的情况要多很多。&#xA;当你在一个维护型项目面前，一边嘴里跑出一万只草尼马，一边还在上面Coding，最后居然还如期交付了维护任务，你能说那是&amp;quot;烂&amp;quot;项目吗?&#xA;我自己也没有遇到过真正&amp;quot;烂&amp;quot;到无法维护的项目，因为我就是那个让项目慢慢变烂的人。&#xA;也许，烂项目的罪证无法像《如何编写无法维护的代码》那样容易罗列，所以你根本就不认为那是烂。&#xA;意识到项目的烂与闻到《代码的坏味道》一样是优秀开发人员的基本素养。&#xA;不过本文说的烂，只是从程序员的角度去看项目，与项目本身的创意，项目在公司层面的战略意义没有关系。&#xA;工具 在我刚毕业参加工作时（2006年左右），那时候的Java生态圈其实已经很强大了，但是我工作过的几家公司，几乎在项目部署上都没有使用太多的自动化工具。&#xA;有的是直接用开发工具Eclipse打包war文件，其中一家公司，甚至是在本地编译Java文件，然后上传class文件到线上服务器，就算那时已经有 Ant 这样的先进工具，可惜我们还是类人猿没有进化过来, 要知道制作和使用工具是智人起源的重要标志.&#xA;如今我们在一个最好的时代, 你有太多的选择， Ant，Maven，Gradle &amp;hellip;&amp;hellip;, 无论如何请把打造高可用自动化工具链与开发高可用系统提升到同样一个高度。&#xA;如果你的项目中使用到了工具，但是它却很脆弱：过多依赖环境，依赖复杂的配置，有时候还会有BUG。&#xA;如果你的项目还不能做到一键命令构建，打包。&#xA;如果你的测试环境和线上环境程序部署时间不在可控范围。&#xA;&amp;hellip;&amp;hellip;&#xA;如果你的项目中有一群还没有意识到低效，重复意味着着危险的开发人员，&#xA;那么你的项目，肯定会慢慢变烂, 因为效率太低。&#xA;框架 是的，从你找工作开始，就肯定听说了这个词，如果你在学校的时候就是一个勤奋好学的同志，那么你早就听说过了，在Java的世界里，你不会几种框架，还好意思出去混吗，于是很多招聘里面都提到，精通Spring,Hibernate,Struts,Mybatis &amp;hellip; 我入职的一家公司，甚至还有公司框架Demo代码学习这个环节。&#xA;So，当你到公司第一次接触到项目的时候，我想上面提到的这几个框架，至少有一个出现在你的项目中，先来看看我遇到的项目中使用框架的情况：&#xA;使用了框架，但是版本已经是上个世纪的了，却依然在线上跑着 依赖同一个第三方开源工具包，却有多个版本 有的地方用了框架的注解配置方式，有的地方却用的XML配置文件 一个本来只需要几十kb代码搞定的项目，最后把框架依赖一起打包，至少几十Mb 没看出来为什么这个项目需要用到这个框架 &amp;hellip;&amp;hellip; 框架一词原本来自建筑学，在软件行业里面，本人理解框架，就是解决特殊场景问题的抽象实现。本着娱乐的精神，这里就不引入太书面的文字，容易引起反感。&#xA;如果你的项目和我遇到的情况一样，满足了上面两点以上，我相信，只要这个项目还要继续，就会继续变烂，原因大概有以下几点：&#xA;你是一个有理想的男青年，你想把机械键盘砸在那个已经不知离职多久的前前前同事的脸上，然后大声喊出来“老子要重构”，然而老板说:可以，你先把这一堆需求实现了再说。 最后老板还是同意了，没事儿你就重构吧，但是，你敢把一个正在好好running的线上项目框架换成最新版本吗？（你的项目用到还不只一个框架，有些框架之间在版本上还有依赖的，你不可能只升级其中一个） 想到这里，再抬头看看周围Coding的同事，有的是已经工作了数年的老腊肉，还有一波刚入职的小鲜肉，他们是否和你一样有理想，有追求呢 &amp;hellip;&amp;hellip; 如果你学过PMP，那么上面这些问题可以概括为风险和成本。&#xA;引入了框架, 那么项目成员是否在框架上做足了技术储备? 如果仅仅是达到使用的地步,那么由于框架引发的问题,你是否能够在最短的时间内解决?&#xA;不然框架就成了项目的枷锁，即使不会让项目慢慢变烂，也不会让项目慢慢变好。&#xA;领域模型 对啊，没问题，我们项目里面的使用Spring，它为我们解决了大部分问题（解决了什么问题？反正我也不知道），Spring不是提倡面向接口编程吗，我们有完善的Service接口层。&#xA;是的，就像上面提到的，我曾经学习过公司的框架Demo代码，里面把Module都分好了，Domain, Dao，Manager（用于管理DAO层的事务），Service，Web。 真实的情况却是，Service里面，一个Service接口对应了一个Dao（大部分情况是这样的），你有几个数据表，大概就有多少个Service接口，如果有个新业务来了，添加了一张表，就再搞一个Service接口,Service，Dao基本都是在为数据库CRUD服务。&#xA;一个接口类从项目产生就没有出现过多个实现, 当时定义接口仅仅是为了遵循面向接口编程。&#xA;在充满疑惑的岁月里，我找到了真相，原来我把名词理解错了，“DDD”的含义有两种，一个是Data-Driven Design，一个是Domain-Driven Design&#xA;一个没有领域模型抽象的项目，迟早要慢慢变烂。&#xA;代码 框架和模型是让你站得更高的角度来看项目,最后还是得回到代码上,好的项目(应该说团队)一定能够找到一套规范(当前流行叫&amp;quot;军规&amp;rdquo;), 每个团队制定的规范可能有些不同,但还是能找到很多共性.&#xA;代码规范(Checkstyle, 方法名,类名规范,注释规范,代码格式规范&amp;hellip;&amp;hellip;) 工程规范(构建流程,版本发布&amp;hellip;&amp;hellip;) 设计规范(设计复杂度控制,模块依赖&amp;hellip;&amp;hellip;) 数据库表设计规范, SQL规范 &amp;hellip;&amp;hellip; 经过我多年的经验，制定规范这事儿，其实重点在如何让项目成员理解和认同，最后才是执行，很多项目成员对规范的抵触源自浮浅地认为规范只能让他们将时间消耗在非功能性需求上。</description>
    </item>
    <item>
      <title>Notification Pattern理解</title>
      <link>//localhost:1313/post/2012-06-20-notification-pattern/</link>
      <pubDate>Wed, 20 Jun 2012 11:24:47 +0000</pubDate>
      <guid>//localhost:1313/post/2012-06-20-notification-pattern/</guid>
      <description>场景 在MVC的架构中，我们想从Model层传递一些错误信息到View层，比如用户注册这个功能，用户填写了密码，邮箱，然后提交注册， 这时候我们后端需要对前端的数据做校验，同时将校验的结果返回给View层，这时候就能用到Notification模式.&#xA;思路 先定义Notification:&#xA;public class Notification { private List _errors; public Notification() { _errors = new ArrayList(); } public void clear() { _errors.clear(); } public boolean hasError() { if (this._errors != null &amp;amp;&amp;amp; this.errors().size() &amp;gt; 0) { return true; } return false; } public List errors() { return this._errors; } public class Error { private String _message; public Error(String messgae) { this._message = messgae; } public String getMessage() { return _message; } public void set_message(String _message) { this.</description>
    </item>
    <item>
      <title></title>
      <link>//localhost:1313/post/2023-12-19-get-to-know-the-bamboo-flute/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2023-12-19-get-to-know-the-bamboo-flute/</guid>
      <description>https://zhuanlan.zhihu.com/p/457436924</description>
    </item>
  </channel>
</rss>

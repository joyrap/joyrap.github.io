<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Software Design on </title>
    <link>//localhost:1313/categories/software-design/</link>
    <description>Recent content in Software Design on </description>
    <generator>Hugo 0.125.0</generator>
    <language>en</language>
    <lastBuildDate>Sat, 09 Apr 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="//localhost:1313/categories/software-design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>API设计之版本控制</title>
      <link>//localhost:1313/post/2022-04-09-api-design-versioning/</link>
      <pubDate>Sat, 09 Apr 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2022-04-09-api-design-versioning/</guid>
      <description>为了追求系统的健壮性，稳定性，越来越多的系统采用分布式软件架构，分布式意味着跨应用访问成为系统交互的一种特点，特别是微服务架构在商业系统中的大量运用。&#xA;API作为应用之间交互协议，当单体应用演变为远程调用后，API持续变更成为一个跨应用或跨团队之间协作的常态，如何维护API，在研发过程中变得尤为重要，非常有必要将API版本控制作为设计的一部分来重视。&#xA;目的 API版本控制的目的是为了降低API在迭代过程中对用户的影响，并提供一套对第三方开发者有利的演进规则，以及升级策略，尽可能避免用户功能被破坏。&#xA;发布管理 变更管理 从服务提供方的视角来看，版本发布与服务实现变更是密切相关的，同时也会对第三方开发者带来影响，所以服务方需要严格管理API版本发布内容，每次发布对API做出不限于以下情况的说明：&#xA;是否在协议不变更的情况，进行了服务优化？ 是否在老协议上新增了入参，新入参对内部业务逻辑有什么影响？ 新增协议与现有协议之间有什么关系，是否是独立的？ 新增协议接口与老接口哪些内容不兼容？告知第三方开发者如何升级。 有些较为庞大的组织，按系统维度进行了API划分，变更说明也应该以系统维度来说明。&#xA;变更的影响说明可以大致分为以下三类：&#xA;1、 API架构变化（影响范围较大，不能兼容） 2、 局部新特性变更（影响较小，提供兼容） 3、 问题修复（完全兼容） 变更说明应该以公开文档的形式公布给第三方开发者。&#xA;生命周期管理 对于整个API来说，必须以两种视角来看到API版本，一种是第三方开发者视角，一种是API服务视角。&#xA;尽管对API进行生命周期管理，好处在于一方面可以控制内部开发节奏，另一方面给第三方开发者提供调试和升级时间。但是在API版本号与API服务内部同时演进的情况下，第三方开发者并不关心API服务内部的演进路线， API服务方也应该尽量减少第三方开发者的理解负担，所以API版本号的变更不易过于频繁。&#xA;不同的业务和产品，对API版本发布的周期管理会有所不同，主要有以下两种主流的版本化管理策略：&#xA;1、基于时间发布 对不同的变更影响，定义不同的发布周期，例如，将API架构变化这种影响范围较大的场景，周期时间应该更长，其次是局部新特性变更，问题修复发布周期最短。&#xA;API架构变化：每三个月发布一次，局部新特性变更：每三周发布一次，问题修复：每周一次。&#xA;不同的业务，可以调整这个周期，但时间周期长短上应该遵循：问题修复 &amp;lt; 局部新特性变更 &amp;lt; API架构变化&#xA;基于时间周期发布，对于第三方开发者来说的好处是可预知性，有明确的API支持时间范围，何时过期，何时被删除。&#xA;1、基于语义化版本号发布 基于语义化版本号的三个维度来管理，例如，版本号:主版本号.次版本号.小版本号&#xA;1、主版本号（对应API架构变化） 2、次版本号（对应局部新特性变更） 3、小版本号（对应问题修复） 版本号发布方式，常用于不需要周期发布的产品，或API在较长的时间范围内稳定的产品。&#xA;同时需要注意：语义化版本号策略更多地是来至API服务方的视角，主要目标是跟踪API不同的兼容性问题。&#xA;基于WEB的API版本发布方案 对于REST API可选的三种方案：&#xA;方案1：将版本号放到路径中，例如：https://api.akulaku.com/v1.0/products/users 或使用不同的域名 https://apiv1.akulaku.com/products/users 方案2：将版本号放在HTTP header头中，例如，在header中放入：v=1.0 方案3：将版本号放到参数中，例如：https://api.akulaku.com/products/users?api-version=1.0 方案1和2都需要借助DNS或API网关对请求路由，不同版本的API路由到不同的API服务上。&#xA;方案3则需要API服务内部管理版本号映射&#xA;API版本号 API内部服务版本号 v1.0 v1.0.0，v1.0.1 v2.0 v2.0.0 &amp;hellip;&amp;hellip; &amp;hellip;&amp;hellip; 案例 Shopify Shopify作为全球最大的一站式商家平台，强大的API为其提供了核心竞争力。&#xA;Shopify的API管理区分了两类API，一类是非版本化的API，一类是版本化的API， 其中版本化的API是基于时间发布。&#xA;例如官方给的REST API demo：/admin/api/2022-07/products.json&#xA;同时官方也提供了API状态周期表：&#xA;Stable version Release date Date stable version is supported until 2021-01 January 1, 2021 January 1, 2022 2021-04 April 1, 2021 April 1, 2022 2021-07 July 1, 2021 July 1, 2022 2021-10 October 1, 2021 October 1, 2022 给第三方调用者提供了明确的API支持时间。</description>
    </item>
    <item>
      <title>A Philosophy Of Software Design-读书笔记</title>
      <link>//localhost:1313/post/2022-01-08-a-philosophy-of-software-design/</link>
      <pubDate>Sat, 08 Jan 2022 00:00:00 +0000</pubDate>
      <guid>//localhost:1313/post/2022-01-08-a-philosophy-of-software-design/</guid>
      <description>《软件设计的哲学》这本书最早出版于2018年，2021年出了2nd Edition，目前国内还没有中文版，这本书是作者 在斯坦福大学开设的CS190课程大纲。 我专门搜索了一下国内软件专业的大学，基本上都没有关于软件设计的课程。&#xA;市面很多关于软件设计的书籍，大部分都是基于某些特定编程语言或者技术，还没有一本全面讲解软件设计本身的书。&#xA;软件设计本来是一种创造性活动，主观性极强，本书作者的基调还是鼓励利用一切手段来考虑系统的设计性，有些做法比较激进。&#xA;这里尝试将其中精彩部分做点翻译，结合自己的理解便于学习。&#xA;2. The Nature of Complexity &amp;lt;复杂性的本质&amp;gt; 这本书是关于如何设计软件系统并最小化复杂性，首先你得了解你的敌人，明确什么是“复杂性”？你如何描述一个系统复杂性？是什么让系统变得复杂？ 本章将在一个更高维度阐述这些问题。&#xA;识别复杂性是重要的设计技能，它让你在处理问题之前明确问题所在，让你在众多选择中作出好的选择。&#xA;2.1 Complexity defined &amp;lt;复杂性的定义&amp;gt; 任何使软件系统难于理解和修改的东西，即是复杂性。复杂性以不同方式存在，比如它可能是一段难于理解的代码，它可能是需要付出巨大努力才能实现一个很小的优化， 它可能是错综复杂的关联中难于修复的BUG。&#xA;复杂性是一个开发人员在某个时间点上试图完成某个特定目标的过程，它不一定是整个系统功能。人们直觉上认为具有大量功能的大型软件系统是”复杂“的，但是这样的系统如果容易实现 ，那么对于本书的定义来说，他就不算复杂。当然几乎所有的大型软件系统实际上都是复杂到难于实现，他们或多或少都会出现我定义的复杂性，也不是说没有复杂功能的简单系统就不可能出现复杂。&#xA;复杂性是由大多数常见的活动决定的，如果一个系统只有很少一部分是复杂的，但它们不影响整个系统复杂性。&#xA;我们可以用一个简单的数学公式来描述系统复杂性：&#xA;$$ C=\sum_{p}c_{p}t_{p} $$&#xA;（p为系统的组件数量，c为组件的复杂性，t为完成组件投入的时间）&#xA;系统的整体复杂性由组成部分乘以开发人员在其投入的工作时间，将复杂性隔离在不容易被发现的地方不亚于完全消除复杂性。&#xA;复杂性相对于作者而言对读者更显而易见，当事者总会觉得他们写的代码似乎很简单，但其他人却觉得复杂。如果你遇到这种情况，试着询问其他 开发人员，为什么你写的代码在他们看来这样复杂，从交流中找到你与他们之间不同的想法。作为开发者你的工作不只是写你认为容易的代码， 同时也要让其他人容易理解。&#xA;2.2 Symptoms of complexity &amp;lt;复杂性的特征&amp;gt; Change amplification&amp;lt;变更放大&amp;gt; 有时候看上去是做一个小的改变，但是需要修改多处代码（功能散落在多处）。好设计的目标是降低每个设计中受影响的代码量。&#xA;Cognitive load&amp;lt;认知负载&amp;gt; 高认知负载意味着开发人员需要花更多的时间去理解需求，这会导致产生BUG的风险，因为他们很容易遗漏一些重要的信息。&#xA;作者用C语言分配内存函数举了一个例子，方法调用方需要自己关心内存释放。&#xA;系统设计师有时候用代码行数来衡量复杂性，代码行数与复杂度并无关系，有时候用更多的代码去实现，也许才是更简单的方式，因为它降低了认知负载。&#xA;Unknown unknowns&amp;lt;未知且不确定&amp;gt;&#xA;没人能够在一个不清楚来龙去脉的系统中完成开发任务，系统中太多不确定性关联，你无法定义自己应该了解到何种程度。&#xA;2.3 Causes of complexity &amp;lt;复杂性的原因&amp;gt; 复杂性由依赖和含糊不清导致。&#xA;依赖是软件的基础部分并不能完全消除，实际上依赖贯穿整个软件设计过程，但是软件设计的一个重要的目标是降低依赖，使依赖尽可能地简单。&#xA;很多时候，一个需要大量文档的系统通常是晦涩难懂的，说明它的设计不清晰，好的设计结果往往只需要少量文档。&#xA;2.5 Complexity is incremental &amp;lt;复杂性的增长&amp;gt; 复杂性在系统中是一个变量，它随着功能一起增长，当它积累到一定程度的时候，将会失去控制很难被消除，所以对于复杂性的增长要“零容忍”。&#xA;3. Working Code isn&amp;rsquo;t Enough &amp;lt;能够工作的代码是不够的&amp;gt; 3.</description>
    </item>
    <item>
      <title>翻译:Understanding the LMAX Disruptor</title>
      <link>//localhost:1313/post/2019-04-19-understanding-the-lmax-disruptor/</link>
      <pubDate>Fri, 19 Apr 2019 21:24:47 +0000</pubDate>
      <guid>//localhost:1313/post/2019-04-19-understanding-the-lmax-disruptor/</guid>
      <description>翻译前言 知道Disruptor这个代码库，是在Log4j 1.X升级版Log4j2中提到的，那时候就好奇它为何如此高效，关于Disruptor的文章在ifeve.com上已经有很多了，这一篇讲的更简单。&#xA;由于个人英文水平有限，更多是意译。&#xA;&amp;mdash;&amp;mdash; 我是分割线 &amp;mdash;&amp;mdash;&#xA;LMAX Disruptor 是由一家金融交易平台公司LMAX Exchange开源的Java包,它为线程间的通信问题提供了极其优雅，高效的解决方案。&#xA;在这篇博文中，我先描述关于传统排队系统在跨线程之间的内存共享问题，然后试图弄清楚LAMX Disruptor 在该问题上有什么特别方案，他们是如何做到的。&#xA;LMAX Disuptor 的解决方案比ArrayBlockingQueue和LinkedBlockingQueue要快。 Mechanical sympathy让你成为更好的开发人员。(更好地理解底层硬件) 在线程中共享内存很容易引发问题，你需要小心对待。 CPU缓存比主存更快，但是不懂得他们是如何工作的(行缓存，等等)反而会严重影响性能。 内存伪共享 举个例子，我们需要对一个计数循环递增到MAX:&#xA;public void simple() { int counter = 0; for (int i = 0; i &amp;lt; MAX; i++) { counter++; } System.out.println(&amp;#34;counter=&amp;#34; + counter); } 因为MAX值可能会很大，为了关注性能，我们决定在多核处理器上来跑这个程序，将这个任务分到两个独立的线程上执行，像这样:&#xA;public void multi() throws Exception { // First thread final Thread t1 = new Thread(() -&amp;gt; { for (int i = 0; i &amp;lt; MAX / 2; i++) { sharedCounter++; } }); // Second thread final Thread t2 = new Thread(() -&amp;gt; { for (int i = 0; i &amp;lt; MAX / 2; i++) { sharedCounter++; } }); // Start threads t1.</description>
    </item>
  </channel>
</rss>
